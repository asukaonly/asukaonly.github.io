<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>404 NOT FOUND/posts/my-first-post/</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="all,follow">
    <meta name="googlebot" content="index,follow,snippet,archive">
    <link rel="stylesheet" href="http://localhost:1313/hugo-theme-console/css/terminal-0.7.2.min.css">
    <link rel="stylesheet" href="http://localhost:1313/hugo-theme-console/css/animate-4.1.1.min.css">
    <link rel="stylesheet" href="http://localhost:1313/hugo-theme-console/css/console.css">
    
      <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
          <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
      <![endif]-->
       <meta property="og:title" content="My First Post" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/my-first-post/" /><meta property="article:published_time" content="2024-05-26T16:41:53+08:00" />



<meta name="twitter:title" content="My First Post"/>
<meta name="twitter:description" content="注：本系列文章所用play版本为1.2.6
介绍 Play framework是个轻量级的RESTful框架，致力于让java程序员实现快速高效开发，它具有以下几个方面的优势：
热加载。在调试模式下，所有修改会及时生效。 抛弃xml配置文件。约定大于配置。 支持异步编程 无状态mvc框架，拓展性良好 简单的路由设置 这里附上Play framework的文档地址，官方有更为详尽的功能叙述。Play framework文档
项目构成 play framework的初始化非常简单，只要下载了play的软件包后，在命令行中运行play new xxx即可初始化一个项目。 自动生成的项目结构如下： 运行play程序也非常简单，在项目目录下使用play run即可运行。
启动脚本解析 play framework软件包目录 为了更好的了解play framework的运作原理，我们来从play framework的启动脚本开始分析，分析启动脚本有助于我们了解play framework的运行过程。 play framework1.2.6软件包解压后的文件如下： play的启动脚本是使用python编写的，脚本的入口为play软件包根目录下的play文件,下面我们将从play这个脚本的主入口开始分析。
play脚本解析 play脚本在开头引入了3个类，分别为play.cmdloader,play.application,play.utils，从添加的系统参数中可以看出play启动脚本的存放路径为 framework/pym cmdloader.py的主要作用为加载framework/pym/commands下的各个脚本文件，用于之后对命令参数的解释运行 application.py的主要作用为解析项目路径下conf/中的配置文件、加载模块、拼接最后运行的java命令 {% codeblock lang:python %} sys.path.append(os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), &lsquo;framework&rsquo;, &lsquo;pym&rsquo;))
from play.cmdloader import CommandLoader from play.application import PlayApplication from play.utils import * {% endcodeblock %}
在脚本的开头，有这么一段代码，意味着只要在play主程序根目录下创建一个名为id的文件，即可设置默认的框架id {% codeblock lang:python %} play_env[&ldquo;id_file&rdquo;] = os.path.join(play_env[&lsquo;basedir&rsquo;], &lsquo;id&rsquo;) if os.path.exists(play_env[&ldquo;id_file&rdquo;]): play_env[&ldquo;id&rdquo;] = open(play_env[&ldquo;id_file&rdquo;])."/>

  


</head>
<body class="terminal">
    <div class="container">
        <div class="terminal-nav">
          <header class="terminal-logo">
            <div class="logo terminal-prompt">
              
              
              <a href="http://localhost:1313/" class="no-style ">404 NOT FOUND</a>:~# 
              <a href='http://localhost:1313/posts'>posts</a>/<a href='http://localhost:1313/posts/my-first-post'>my-first-post</a>/</div></header>
          <nav class="terminal-menu">
            <ul vocab="https://schema.org/" typeof="BreadcrumbList">
                
            </ul>
          </nav>
        </div>
    </div>

    <div class="container " >
        
<h1>My First Post</h1>

May. 26, 2024


<br/><br/>
<p><!-- raw HTML omitted -->注：本系列文章所用play版本为1.2.6<!-- raw HTML omitted --></p>
<hr>
<h1 id="介绍">介绍</h1>
<p>Play framework是个轻量级的RESTful框架，致力于让java程序员实现快速高效开发，它具有以下几个方面的优势：</p>
<ol>
<li>热加载。在调试模式下，所有修改会及时生效。</li>
<li>抛弃xml配置文件。约定大于配置。</li>
<li>支持异步编程</li>
<li>无状态mvc框架，拓展性良好</li>
<li>简单的路由设置</li>
</ol>
<p>这里附上Play framework的文档地址，官方有更为详尽的功能叙述。<a href="https://www.playframework.com/documentation/1.2.x/overview" title="文档">Play framework文档</a></p>
<hr>
<!-- raw HTML omitted -->
<h1 id="项目构成">项目构成</h1>
<p>play framework的初始化非常简单，只要下载了play的软件包后，在命令行中运行play new xxx即可初始化一个项目。
自动生成的项目结构如下：
<img src="https://i.loli.net/2018/01/08/5a53879bec91f.png" alt="play项目结构">
运行play程序也非常简单，在项目目录下使用play run即可运行。</p>
<hr>
<h1 id="启动脚本解析">启动脚本解析</h1>
<h2 id="play-framework软件包目录">play framework软件包目录</h2>
<p>为了更好的了解play framework的运作原理，我们来从play framework的启动脚本开始分析，分析启动脚本有助于我们了解play framework的运行过程。
play framework1.2.6软件包解压后的文件如下：
<img src="https://i.loli.net/2018/01/08/5a5386dfdfdb6.png" alt="play项目结构">
play的启动脚本是使用python编写的，脚本的入口为play软件包根目录下的play文件,下面我们将从play这个脚本的主入口开始分析。</p>
<h2 id="play脚本解析">play脚本解析</h2>
<p>play脚本在开头引入了3个类，分别为play.cmdloader,play.application,play.utils，从添加的系统参数中可以看出play启动脚本的存放路径为 framework/pym
cmdloader.py的主要作用为加载framework/pym/commands下的各个脚本文件，用于之后对命令参数的解释运行
application.py的主要作用为解析项目路径下conf/中的配置文件、加载模块、拼接最后运行的java命令
{% codeblock lang:python  %}
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), &lsquo;framework&rsquo;, &lsquo;pym&rsquo;))</p>
<p>from play.cmdloader import CommandLoader
from play.application import PlayApplication
from play.utils import *
{% endcodeblock %}</p>
<p>在脚本的开头，有这么一段代码，意味着只要在play主程序根目录下创建一个名为id的文件，即可设置默认的框架id
{% codeblock lang:python  %}
play_env[&ldquo;id_file&rdquo;] = os.path.join(play_env[&lsquo;basedir&rsquo;], &lsquo;id&rsquo;)
if os.path.exists(play_env[&ldquo;id_file&rdquo;]):
play_env[&ldquo;id&rdquo;] = open(play_env[&ldquo;id_file&rdquo;]).readline().strip()
else:
play_env[&ldquo;id&rdquo;] = &rsquo;&rsquo;
{% endcodeblock %}</p>
<p>命令参数的分隔由以下代码完成，例如使用了play run &ndash;%test,那么参数列表就是<code>[&quot;xxxx\play&quot;,&quot;run&quot;,&quot;--%test&quot;]</code>，这段代码也说明了，play的命令格式为 <code>play cmd [app_path] [--options]</code>
{% codeblock lang:python  %}
application_path = None
remaining_args = []
if len(sys.argv) == 1:
application_path = os.getcwd()
if len(sys.argv) == 2:
application_path = os.getcwd()
remaining_args = sys.argv[2:]
if len(sys.argv) &gt; 2:
if sys.argv[2].startswith(&rsquo;-&rsquo;):
application_path = os.getcwd()
remaining_args = sys.argv[2:]
else:
application_path = os.path.normpath(os.path.abspath(sys.argv[2]))
remaining_args = sys.argv[3:]
{% endcodeblock %}</p>
<p>在play参数中，有一个ignoreMissing，这个参数的全称其实是ignoreMissingModules，作用就是在当配置文件中配置有模块但是在play目录下并没有找到时是否忽略，如需忽略那么在启动时需要加入<code>--force</code>
{% codeblock lang:python  %}
ignoreMissing = False
if remaining_args.count(&rsquo;&ndash;force&rsquo;) == 1:
remaining_args.remove(&rsquo;&ndash;force&rsquo;)
ignoreMissing = True
{% endcodeblock %}</p>
<p>脚本通过<code>play_app = PlayApplication(application_path, play_env, ignoreMissing)</code>和<code>cmdloader = CommandLoader(play_env[&quot;basedir&quot;])</code>来进行PlayApplication类和CommandLoader类的初始化。
在PlayApplication类的初始化过程中，它创建了PlayConfParser类用来解析配置文件，这也就是说play的配置文件解析是在脚本启动阶段进行的，这也是为什么修改配置文件无法实时生效需要重启的原因
在PlayConfParser中有一个常量DEFAULTS储存了默认的http端口和jpda调试端口，分别为9000和8000，需要添加默认值可以修改DEFAULTS，DEFAULTS内的值只有当配置文件中找不到时才会生效。
{% codeblock lang:python  %}
DEFAULTS = {
&lsquo;http.port&rsquo;: &lsquo;9000&rsquo;,
&lsquo;jpda.port&rsquo;: &lsquo;8000&rsquo;
}
{% endcodeblock %}</p>
<p>值得一提的是，配置文件中的http.port的优先级是小于命令参数中的http.port的
{% codeblock lang:python  %}
#env为命令参数
if env.has_key(&lsquo;http.port&rsquo;):
self.entries[&lsquo;http.port&rsquo;] = env[&lsquo;http.port&rsquo;]
{% endcodeblock %}</p>
<p>CommandLoader类的功能很简单，就是遍历framework/pym/commands下的.py文件，依次加载然后读取他的全局变量COMMANDS和MODULE储存用于之后的命令处理和模块加载。</p>
<p>回到play脚本中，在PlayApplication类和CommandLoader类初始化完成之后，play进行&quot;&ndash;deps&quot;参数的检查，如果存在&ndash;deps，则调用<code>play.deps.DependenciesManager</code>类来进行依赖的检查、更新。DependenciesManager的解析将放到后话详解。
{% codeblock lang:python  %}
if remaining_args.count(&rsquo;&ndash;deps&rsquo;) == 1:
cmdloader.commands[&lsquo;dependencies&rsquo;].execute(command=&lsquo;dependencies&rsquo;, app=play_app, args=[&rsquo;&ndash;sync&rsquo;], env=play_env, cmdloader=cmdloader)
remaining_args.remove(&rsquo;&ndash;deps&rsquo;)
{% endcodeblock %}</p>
<p>接下来，play便正式进行启动过程，play按照以下的顺序进行加载：</p>
<ol>
<li>加载配置文件中记录的模块的命令信息</li>
<li>加载参数中指定的模块的命令信息</li>
<li>运行各模块中的before函数</li>
<li>执行play_command,play_command即为run,test,war等play需要的执行的命令</li>
<li>运行各模块中的after函数</li>
<li>结束脚本</li>
</ol>
<p>{% codeblock lang:python  %}
if play_command in cmdloader.commands:
for name in cmdloader.modules:
module = cmdloader.modules[name]
if &lsquo;before&rsquo; in dir(module):
module.before(command=play_command, app=play_app, args=remaining_args, env=play_env)
status = cmdloader.commands[play_command].execute(command=play_command, app=play_app, args=remaining_args, env=play_env, cmdloader=cmdloader)
for name in cmdloader.modules:
module = cmdloader.modules[name]
if &lsquo;after&rsquo; in dir(module):
module.after(command=play_command, app=play_app, args=remaining_args, env=play_env)
sys.exit(status)
{% endcodeblock %}</p>
<p>下面，我们来看看play常用命令的运行过程&hellip;</p>
<h2 id="play常用运行命令解析">Play常用运行命令解析</h2>
<p>在本节的一开始，我决定先把play所有的可用命令先列举一下，以便读者可以选择性阅读。</p>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>命令所在文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>antify</td>
<td>ant.py</td>
<td>初始化ant构建工具的build.xml文件</td>
</tr>
<tr>
<td>run</td>
<td>base.py</td>
<td>运行程序</td>
</tr>
<tr>
<td>new</td>
<td>base.py</td>
<td>新建play应用</td>
</tr>
<tr>
<td>clean</td>
<td>base.py</td>
<td>删除临时文件，即清空tmp文件夹</td>
</tr>
<tr>
<td>test</td>
<td>base.py</td>
<td>运行测试程序</td>
</tr>
<tr>
<td>autotest、auto-test</td>
<td>base.py</td>
<td>自动运行所有测试项目</td>
</tr>
<tr>
<td>id</td>
<td>base.py</td>
<td>设置项目id</td>
</tr>
<tr>
<td>new,run</td>
<td>base.py</td>
<td>新建play应用并启动</td>
</tr>
<tr>
<td>clean,run</td>
<td>base.py</td>
<td>删除临时文件并运行</td>
</tr>
<tr>
<td>modules</td>
<td>base.py</td>
<td>显示项目用到的模块，注：这里显示的模块只是在项目配置文件中引用的模块，命令参数中添加的模块不会显示</td>
</tr>
<tr>
<td>check</td>
<td>check.py</td>
<td>检查play更新</td>
</tr>
<tr>
<td>classpath、cp</td>
<td>classpath.py</td>
<td>显示应用的classpath</td>
</tr>
<tr>
<td>start</td>
<td>daemon.py</td>
<td>在后台运行play程序</td>
</tr>
<tr>
<td>stop</td>
<td>daemon.py</td>
<td>停止正在运行的程序</td>
</tr>
<tr>
<td>restart</td>
<td>daemon.py</td>
<td>重启正在运行的程序</td>
</tr>
<tr>
<td>pid</td>
<td>daemon.py</td>
<td>显示运行中的程序的pid</td>
</tr>
<tr>
<td>out</td>
<td>daemon.py</td>
<td>显示输出</td>
</tr>
<tr>
<td>dependencies、deps</td>
<td>deps.py</td>
<td>运行DependenciesManager更新依赖</td>
</tr>
<tr>
<td>eclipsify、ec</td>
<td>eclipse.py</td>
<td>创建eclipse配置文件</td>
</tr>
<tr>
<td>evolutions</td>
<td>evolutions.py</td>
<td>运行play.db.Evolutions进行数据库演变检查</td>
</tr>
<tr>
<td>help</td>
<td>help.py</td>
<td>输出所有play的可用命令</td>
</tr>
<tr>
<td>idealize、idea</td>
<td>intellij.py</td>
<td>生成idea配置文件</td>
</tr>
<tr>
<td>javadoc</td>
<td>javadoc.py</td>
<td>生成javadoc</td>
</tr>
<tr>
<td>new-module、nm</td>
<td>modulesrepo.py</td>
<td>创建新模块</td>
</tr>
<tr>
<td>list-modules、lm</td>
<td>modulesrepo.py</td>
<td>显示play社区中的模块</td>
</tr>
<tr>
<td>build-module、bm</td>
<td>modulesrepo.py</td>
<td>打包模块</td>
</tr>
<tr>
<td>add</td>
<td>modulesrepo.py</td>
<td>将模块添加至项目</td>
</tr>
<tr>
<td>install</td>
<td>modulesrepo.py</td>
<td>安装模块</td>
</tr>
<tr>
<td>netbeansify</td>
<td>netbeans.py</td>
<td>生成netbeans配置文件</td>
</tr>
<tr>
<td>precompile</td>
<td>precompile.py</td>
<td>预编译</td>
</tr>
<tr>
<td>secret</td>
<td>secret.py</td>
<td>生成secret key</td>
</tr>
<tr>
<td>status</td>
<td>status.py</td>
<td>显示运行中项目的状态</td>
</tr>
<tr>
<td>version</td>
<td>version.py</td>
<td>显示play framework的版本号</td>
</tr>
<tr>
<td>war</td>
<td>war.py</td>
<td>将项目打包为war文件</td>
</tr>
</tbody>
</table>
<h3 id="run与start">run与start</h3>
<p>run应该是我们平时用的最多的命令了，run命令的作用其实很简单，就是根据命令参数拼接java参数，然后调用java来运行play.server.Server，run函数的代码如下:
{% codeblock lang:python  %}
def run(app, args):
#app即为play脚本中创建的PlayApplication类
global process
#这里检查是否存在conf/routes和conf/application.conf
app.check()</p>
<pre><code>print &quot;~ Ctrl+C to stop&quot;
print &quot;~ &quot;
java_cmd = app.java_cmd(args)
try:
    process = subprocess.Popen (java_cmd, env=os.environ)
    signal.signal(signal.SIGTERM, handle_sigterm)
    return_code = process.wait()
signal.signal(signal.SIGINT, handle_sigint)
    if 0 != return_code:
        sys.exit(return_code)
except OSError:
    print &quot;Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). &quot;
    sys.exit(-1)
print
</code></pre>
<p>{% endcodeblock %}</p>
<p>app.java_cmd(args)的实现代码如下：
{% codeblock lang:python  %}
def java_cmd(self, java_args, cp_args=None, className=&lsquo;play.server.Server&rsquo;, args = None):
if args is None:
args = [&rsquo;&rsquo;]
memory_in_args=False</p>
<pre><code>#检查java参数中是否有jvm内存设置
for arg in java_args:
    if arg.startswith('-Xm'):
        memory_in_args=True
#如果参数中无jvm内存设置，那么在配置文件中找是否有jvm内存设置，若还是没有则在环境变量中找是否有JAVA_OPTS
#这里其实有个问题，这里假定的是JAVA_OPTS变量里只存了jvm内存设置，如果JAVA_OPTS还存了其他选项，那对运行可能有影响
if not memory_in_args:
    memory = self.readConf('jvm.memory')
    if memory:
        java_args = java_args + memory.split(' ')
    elif 'JAVA_OPTS' in os.environ:
        java_args = java_args + os.environ['JAVA_OPTS'].split(' ')
#获取程序的classpath
if cp_args is None:
    cp_args = self.cp_args()
#读取配置文件中的jpda端口
self.jpda_port = self.readConf('jpda.port')
#读取配置文件中的运行模式
application_mode = self.readConf('application.mode').lower()
#如果模式是prod，则用server模式编译
if application_mode == 'prod':
    java_args.append('-server')
# JDK 7 compat
# 使用新class校验器 (不知道作用)
java_args.append('-XX:-UseSplitVerifier')
#查找配置文件中是否有java安全配置，如果有则加入java参数中
java_policy = self.readConf('java.policy')
if java_policy != '':
    policyFile = os.path.join(self.path, 'conf', java_policy)
    if os.path.exists(policyFile):
        print &quot;~ using policy file \&quot;%s\&quot;&quot; % policyFile
        java_args.append('-Djava.security.manager')
        java_args.append('-Djava.security.policy==%s' % policyFile)
#加入http端口设置
if self.play_env.has_key('http.port'):
    args += [&quot;--http.port=%s&quot; % self.play_env['http.port']]
#加入https端口设置
if self.play_env.has_key('https.port'):
    args += [&quot;--https.port=%s&quot; % self.play_env['https.port']]

#设置文件编码
java_args.append('-Dfile.encoding=utf-8')
#设置编译命令 (这边使用了jregex/Pretokenizer类的next方法，不知道有什么用)
java_args.append('-XX:CompileCommand=exclude,jregex/Pretokenizer,next')

#如果程序模式在dev，则添加jpda调试器参数
if self.readConf('application.mode').lower() == 'dev':
    if not self.play_env[&quot;disable_check_jpda&quot;]: self.check_jpda()
    java_args.append('-Xdebug')
    java_args.append('-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n' % self.jpda_port)
    java_args.append('-Dplay.debug=yes')
#拼接java参数
java_cmd = [self.java_path(), '-javaagent:%s' % self.agent_path()] + java_args + ['-classpath', cp_args, '-Dapplication.path=%s' % self.path, '-Dplay.id=%s' % self.play_env[&quot;id&quot;], className] + args
return java_cmd
</code></pre>
<p>{% endcodeblock %}</p>
<p>start命令与run命令很类似，执行步骤为：</p>
<ol>
<li>依次查找play变量pid_file、系统环境变量PLAY_PID_PATH、项目根目录下server.pid，查找是否存在指定pid</li>
<li>若第一步找到pid，查找当前进程列表中是否存在此pid进程，存在则试图关闭进程。(如果此pid不是play的进程呢。。。)</li>
<li>在配置文件中找application.log.system.out看是否关闭了系统输出</li>
<li>启动程序，这里与run命令唯一的区别就是他指定了stdout位置，这样就变成了后台程序</li>
<li>将启动后的程序的pid写入server.pid</li>
</ol>
<p>stop命令即关闭当前进程，这里要提一下，play有个注解叫OnApplicationStop，即会在程序停止时触发，而OnApplicationStop的实现主要是调用了<code>Runtime.getRuntime().addShutdownHook();</code>来完成</p>
<h3 id="test与autotest">test与autotest</h3>
<p>使用play test命令可以让程序进入测试模式，test命令和run命令其实差别不大，唯一的区别就在于使用test命令时，脚本会将play id自动替换为test，当play id为test时会自动引入testrunner模块，testrunner模块主要功能为添加@tests路由并实现了test测试页面，他的具体实现过程后续再谈。
autotest命令的作用是自动测试所有的测试用例，他的执行顺序是这样的：</p>
<ol>
<li>检查是否存在tmp文件夹，存在即删除</li>
<li>检查是否有程序正在运行，如存在则关闭程序</li>
<li>检查程序是否配置了ssl但是没有指定证书</li>
<li>检查是否存在test-result文件夹，存在即删除</li>
<li>使用test作为id重启程序</li>
<li>调用play.modules.testrunner.FirePhoque来进行自动化测试</li>
<li>关闭程序</li>
</ol>
<p>autotest的脚本的步骤1和2我觉得是有问题的，应该换下顺序，不然如果程序正在向tmp文件夹插入临时文件，那么tmp文件夹就删除失败了。
关闭程序的代码调用了<code>http://localhost:%http_port/@kill</code>进行关闭，@kill的实现方法在play.CorePlugin下，注意，@kill在prod模式下无效~~(这是废话)~~
由于使用了python作为启动脚本，无法通过java内部变量值判断程序是否开启，只能查看控制台的输出日志，所以在使用test作为id重启后，脚本使用下面的代码判断程序是否完全启动：
{% codeblock lang:python  %}
try:
#这里启动程序
play_process = subprocess.Popen(java_cmd, env=os.environ, stdout=sout)
except OSError:
print &ldquo;Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). &quot;
sys.exit(-1)
#打开日志输出文件
soutint = open(os.path.join(app.log_path(), &lsquo;system.out&rsquo;), &lsquo;r&rsquo;)
while True:
if play_process.poll():
print &ldquo;~&rdquo;
print &ldquo;~ Oops, application has not started?&rdquo;
print &ldquo;~&rdquo;
sys.exit(-1)
line = soutint.readline().strip()
if line:
print line
#若出现&rsquo;Server is up and running&rsquo;则正常启动
if line.find(&lsquo;Server is up and running&rsquo;) &gt; -1: # This line is written out by Server.java to system.out and is not log file dependent
soutint.close()
break
{% endcodeblock %}
firephoque类的实现过程我们之后再详解。</p>
<h3 id="new与clean">new与clean</h3>
<p>我们使用new来创建一个新项目，play new的使用方法为<code>play new project-name [--with] [--name]</code>。
with参数为项目所使用的模块。
name为项目名，这里要注意一点，projectname和&ndash;name的参数可以设置为不同值，projectname是项目建立的文件夹名，&ndash;name的值为项目配置文件中的application.name。
如果不加&ndash;name，脚本会提示你是否使用projectname作为名字，在确认之后，脚本会将resources/application-skel中的所有文件拷贝到projectname文件夹下，然后用输入的name替换项目配置文件下的application.name，并生成一个64位的secretKey替换配置文件中的secretKey。
接着，脚本会查找使用的模块中是否存在dependencies.yml，并将dependencies.yml中的内容加入项目的dependencies.yml中，并调用DependenciesManager检查依赖状态。</p>
<p>new函数的主要代码如下:
{% codeblock lang:python  %}
print &ldquo;~ The new application will be created in %s&rdquo; % os.path.normpath(app.path)
if application_name is None:
application_name = raw_input(&quot;~ What is the application name? [%s] &quot; % os.path.basename(app.path))
if application_name == &ldquo;&rdquo;:
application_name = os.path.basename(app.path)
copy_directory(os.path.join(env[&ldquo;basedir&rdquo;], &lsquo;resources/application-skel&rsquo;), app.path)
os.mkdir(os.path.join(app.path, &lsquo;app/models&rsquo;))
os.mkdir(os.path.join(app.path, &rsquo;lib&rsquo;))
app.check()
replaceAll(os.path.join(app.path, &lsquo;conf/application.conf&rsquo;), r&rsquo;%APPLICATION_NAME%&rsquo;, application_name)
replaceAll(os.path.join(app.path, &lsquo;conf/application.conf&rsquo;), r&rsquo;%SECRET_KEY%&rsquo;, secretKey())
print &ldquo;~&rdquo;
{% endcodeblock %}</p>
<p>clean命令非常简单，就是删除整个tmp文件夹</p>
<h3 id="war与precompile">war与precompile</h3>
<p>很多时候，我们需要使用tomcat等服务器容器作为服务载体，这时候就需要将play应用打包为war
war的使用参数是<code>play war project-name [-o/--output][filename] [--zip] [--exclude][exclude-directories]</code>
使用-o或&ndash;output来指定输出文件夹，使用&ndash;zip压缩为war格式，使用&ndash;exclude来包含另外需要打包的文件夹
要注意的是，必须在项目目录外进行操作，不然会失败
在参数处理完毕后，脚本正式开始打包过程，分为2个步骤：1.预编译。2：打包
预编译即用到了precompile命令，precompile命令与run命令几乎一样，只是在java参数中加入了<code>precompile=yes</code>,<del>这里要注意下，这里加入的precompile值是yes，不是true，所以Play类中的usePrecompiled是false</del>这里搞错了，Play类中的usePrecompiled检查的参数是precompiled，而不是precompile
让我们来看一下加入了这个java参数对程序的影响。
与预编译有关的代码主要是下面2段：
{% codeblock lang:java  %}
static boolean preCompile() {
if (usePrecompiled) {
if (Play.getFile(&ldquo;precompiled&rdquo;).exists()) {
classloader.getAllClasses();
Logger.info(&ldquo;Application is precompiled&rdquo;);
return true;
}
Logger.error(&ldquo;Precompiled classes are missing!!&rdquo;);
fatalServerErrorOccurred();
return false;
}
//这里开始预编译
try {
Logger.info(&ldquo;Precompiling &hellip;&rdquo;);
Thread.currentThread().setContextClassLoader(Play.classloader);
long start = System.currentTimeMillis();
//getAllClasses方法较长，就不贴了，下面一段代码在getAllClasses方法中进入
classloader.getAllClasses();</p>
<pre><code>        if (Logger.isTraceEnabled()) {
            Logger.trace(&quot;%sms to precompile the Java stuff&quot;, System.currentTimeMillis() - start);
        }

        if (!lazyLoadTemplates) {
            start = System.currentTimeMillis();
            //编译模板
            TemplateLoader.getAllTemplate();

            if (Logger.isTraceEnabled()) {
                Logger.trace(&quot;%sms to precompile the templates&quot;, System.currentTimeMillis() - start);
            }
        }
        return true;
    } catch (Throwable e) {
        Logger.error(e, &quot;Cannot start in PROD mode with errors&quot;);
        fatalServerErrorOccurred();
        return false;
    }
}
</code></pre>
<p>{% endcodeblock %}</p>
<p>{% codeblock lang:java  %}
public byte[] enhance() {
this.enhancedByteCode = this.javaByteCode;
if (isClass()) {</p>
<pre><code>        // before we can start enhancing this class we must make sure it is not a PlayPlugin.
        // PlayPlugins can be included as regular java files in a Play-application.
        // If a PlayPlugin is present in the application, it is loaded when other plugins are loaded.
        // All plugins must be loaded before we can start enhancing.
        // This is a problem when loading PlayPlugins bundled as regular app-class since it uses the same classloader
        // as the other (soon to be) enhanched play-app-classes.
        boolean shouldEnhance = true;
        try {
            CtClass ctClass = enhanceChecker_classPool.makeClass(new ByteArrayInputStream(this.enhancedByteCode));
            if (ctClass.subclassOf(ctPlayPluginClass)) {
                shouldEnhance = false;
            }
        } catch( Exception e) {
            // nop
        }

        if (shouldEnhance) {
            Play.pluginCollection.enhance(this);
        }
    }

    //主要是这一段，他将增强处理后的字节码写入了文件，增强处理在之后会深入展开
    if (System.getProperty(&quot;precompile&quot;) != null) {
        try {
            // emit bytecode to standard class layout as well
            File f = Play.getFile(&quot;precompiled/java/&quot; + (name.replace(&quot;.&quot;, &quot;/&quot;)) + &quot;.class&quot;);
            f.getParentFile().mkdirs();
            FileOutputStream fos = new FileOutputStream(f);
            fos.write(this.enhancedByteCode);
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return this.enhancedByteCode;
}
</code></pre>
<p>{% endcodeblock %}
预编译过程结束后，脚本正式开始打包过程，打包过程比较简单，就是讲预编译后的字节码文件、模板文件、配置文件、使用的类库、使用的模块类库等移动至WEB-INF文件夹中，如果使用了&ndash;zip，那么脚本会将生成的文件夹用zip格式打包。</p>
<h3 id="secret和status">secret和status</h3>
<p>secret命令能生成一个新的secret key
status命令是用于实时显示程序的运行状态，脚本的运作十分简单，步骤如下：</p>
<ol>
<li>检查是否有&ndash;url参数，有则在他之后添加@status</li>
<li>检查是否存在&ndash;secret</li>
<li>如果没有&ndash;url，则使用<code>http://localhost:%http_port/@status</code>;如果没有 &ndash;secret，则从配置文件中读取secret key</li>
<li>将secret_key、&rsquo;@status&rsquo;使用sha加密，并加入Authorization请求头</li>
<li>发送请求</li>
</ol>
<p>@status的实现和@kill一样在CorePlugin类中，这在之后再进行详解。</p>
<h1 id="总结">总结</h1>
<p>Play的启动脚本分析至此就结束了，从脚本的分析过程中我们可以稍微探究下Play在脚本启动阶段有何行为，这对我们进行脚本改造或者启动优化还是非常有帮助的。
下一篇，我们来看看Play的启动类是如何运作的。。</p>



        <div class="footer">
    Powered by <a href="https://gohugo.io/">Hugo</a> with
    <a href="https://github.com/mrmierzejewski/hugo-theme-console/">Console Theme</a>. 
</div>

    </div>
  </body>
</html>
