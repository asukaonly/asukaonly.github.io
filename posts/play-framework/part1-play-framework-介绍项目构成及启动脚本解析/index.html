<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Play framework源码解析 Part1: Play framework 介绍、项目构成及启动脚本解析 | 404 NOT FOUND</title><meta name=keywords content="program,backend"><meta name=description content='注：本系列文章所用play版本为1.2.6

介绍
Play framework是个轻量级的RESTful框架，致力于让java程序员实现快速高效开发，它具有以下几个方面的优势：

热加载。在调试模式下，所有修改会及时生效。
抛弃xml配置文件。约定大于配置。
支持异步编程
无状态mvc框架，拓展性良好
简单的路由设置

这里附上Play framework的文档地址，官方有更为详尽的功能叙述。Play framework文档


项目构成
play framework的初始化非常简单，只要下载了play的软件包后，在命令行中运行play new xxx即可初始化一个项目。
自动生成的项目结构如下：

运行play程序也非常简单，在项目目录下使用
play run
即可运行。

启动脚本解析
play framework软件包目录
为了更好的了解play framework的运作原理，我们来从play framework的启动脚本开始分析，分析启动脚本有助于我们了解play framework的运行过程。
play的启动脚本是使用python编写的，脚本的入口为play软件包根目录下的play文件,下面我们将从play这个脚本的主入口开始分析。

play脚本解析
play脚本在开头引入了3个类，分别为play.cmdloader,play.application,play.utils，从添加的系统参数中可以看出play启动脚本的存放路径为 framework/pym
cmdloader.py的主要作用为加载framework/pym/commands下的各个脚本文件，用于之后对命令参数的解释运行
application.py的主要作用为解析项目路径下conf/中的配置文件、加载模块、拼接最后运行的java命令
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), &#39;framework&#39;, &#39;pym&#39;))

from play.cmdloader import CommandLoader
from play.application import PlayApplication
from play.utils import *
在脚本的开头，有这么一段代码，意味着只要在play主程序根目录下创建一个名为id的文件，即可设置默认的框架id
play_env["id_file"] = os.path.join(play_env[&#39;basedir&#39;], &#39;id&#39;)
if os.path.exists(play_env["id_file"]):
    play_env["id"] = open(play_env["id_file"]).readline().strip()
else:
    play_env["id"] = &#39;&#39;
命令参数的分隔由以下代码完成，例如使用了play run &ndash;%test,那么参数列表就是

[&ldquo;xxxx\play&rdquo;,&ldquo;run&rdquo;,"&ndash;%test"]
这段代码也说明了，play的命令格式为

play cmd [app_path] [&ndash;options]'><meta name=author content="luyanliang"><link rel=canonical href=https://example.org/posts/play-framework/part1-play-framework-%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://example.org/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://example.org/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://example.org/avatar.png><link rel=apple-touch-icon href=https://example.org/avatar.png><link rel=mask-icon href=https://example.org/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://example.org/posts/play-framework/part1-play-framework-%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://example.org/posts/play-framework/part1-play-framework-%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="404 NOT FOUND"><meta property="og:title" content="Play framework源码解析 Part1: Play framework 介绍、项目构成及启动脚本解析"><meta property="og:description" content='注：本系列文章所用play版本为1.2.6
介绍 Play framework是个轻量级的RESTful框架，致力于让java程序员实现快速高效开发，它具有以下几个方面的优势：
热加载。在调试模式下，所有修改会及时生效。 抛弃xml配置文件。约定大于配置。 支持异步编程 无状态mvc框架，拓展性良好 简单的路由设置 这里附上Play framework的文档地址，官方有更为详尽的功能叙述。Play framework文档
项目构成 play framework的初始化非常简单，只要下载了play的软件包后，在命令行中运行play new xxx即可初始化一个项目。 自动生成的项目结构如下：
运行play程序也非常简单，在项目目录下使用
play run 即可运行。
启动脚本解析 play framework软件包目录 为了更好的了解play framework的运作原理，我们来从play framework的启动脚本开始分析，分析启动脚本有助于我们了解play framework的运行过程。
play的启动脚本是使用python编写的，脚本的入口为play软件包根目录下的play文件,下面我们将从play这个脚本的主入口开始分析。
play脚本解析 play脚本在开头引入了3个类，分别为play.cmdloader,play.application,play.utils，从添加的系统参数中可以看出play启动脚本的存放路径为 framework/pym cmdloader.py的主要作用为加载framework/pym/commands下的各个脚本文件，用于之后对命令参数的解释运行 application.py的主要作用为解析项目路径下conf/中的配置文件、加载模块、拼接最后运行的java命令
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), &#39;framework&#39;, &#39;pym&#39;)) from play.cmdloader import CommandLoader from play.application import PlayApplication from play.utils import * 在脚本的开头，有这么一段代码，意味着只要在play主程序根目录下创建一个名为id的文件，即可设置默认的框架id
play_env["id_file"] = os.path.join(play_env[&#39;basedir&#39;], &#39;id&#39;) if os.path.exists(play_env["id_file"]): play_env["id"] = open(play_env["id_file"]).readline().strip() else: play_env["id"] = &#39;&#39; 命令参数的分隔由以下代码完成，例如使用了play run –%test,那么参数列表就是
[“xxxx\play”,“run”,"–%test"]
这段代码也说明了，play的命令格式为
play cmd [app_path] [–options]'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-03T13:56:21+00:00"><meta property="article:modified_time" content="2018-01-03T13:56:21+00:00"><meta property="article:tag" content="Program"><meta property="article:tag" content="Backend"><meta property="og:image" content="https://example.org/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://example.org/avatar.png"><meta name=twitter:title content="Play framework源码解析 Part1: Play framework 介绍、项目构成及启动脚本解析"><meta name=twitter:description content='注：本系列文章所用play版本为1.2.6

介绍
Play framework是个轻量级的RESTful框架，致力于让java程序员实现快速高效开发，它具有以下几个方面的优势：

热加载。在调试模式下，所有修改会及时生效。
抛弃xml配置文件。约定大于配置。
支持异步编程
无状态mvc框架，拓展性良好
简单的路由设置

这里附上Play framework的文档地址，官方有更为详尽的功能叙述。Play framework文档


项目构成
play framework的初始化非常简单，只要下载了play的软件包后，在命令行中运行play new xxx即可初始化一个项目。
自动生成的项目结构如下：

运行play程序也非常简单，在项目目录下使用
play run
即可运行。

启动脚本解析
play framework软件包目录
为了更好的了解play framework的运作原理，我们来从play framework的启动脚本开始分析，分析启动脚本有助于我们了解play framework的运行过程。
play的启动脚本是使用python编写的，脚本的入口为play软件包根目录下的play文件,下面我们将从play这个脚本的主入口开始分析。

play脚本解析
play脚本在开头引入了3个类，分别为play.cmdloader,play.application,play.utils，从添加的系统参数中可以看出play启动脚本的存放路径为 framework/pym
cmdloader.py的主要作用为加载framework/pym/commands下的各个脚本文件，用于之后对命令参数的解释运行
application.py的主要作用为解析项目路径下conf/中的配置文件、加载模块、拼接最后运行的java命令
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), &#39;framework&#39;, &#39;pym&#39;))

from play.cmdloader import CommandLoader
from play.application import PlayApplication
from play.utils import *
在脚本的开头，有这么一段代码，意味着只要在play主程序根目录下创建一个名为id的文件，即可设置默认的框架id
play_env["id_file"] = os.path.join(play_env[&#39;basedir&#39;], &#39;id&#39;)
if os.path.exists(play_env["id_file"]):
    play_env["id"] = open(play_env["id_file"]).readline().strip()
else:
    play_env["id"] = &#39;&#39;
命令参数的分隔由以下代码完成，例如使用了play run &ndash;%test,那么参数列表就是

[&ldquo;xxxx\play&rdquo;,&ldquo;run&rdquo;,"&ndash;%test"]
这段代码也说明了，play的命令格式为

play cmd [app_path] [&ndash;options]'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://example.org/posts/"},{"@type":"ListItem","position":2,"name":"Play framework源码解析 Part1: Play framework 介绍、项目构成及启动脚本解析","item":"https://example.org/posts/play-framework/part1-play-framework-%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Play framework源码解析 Part1: Play framework 介绍、项目构成及启动脚本解析","name":"Play framework源码解析 Part1: Play framework 介绍、项目构成及启动脚本解析","description":"注：本系列文章所用play版本为1.2.6\n介绍 Play framework是个轻量级的RESTful框架，致力于让java程序员实现快速高效开发，它具有以下几个方面的优势：\n热加载。在调试模式下，所有修改会及时生效。 抛弃xml配置文件。约定大于配置。 支持异步编程 无状态mvc框架，拓展性良好 简单的路由设置 这里附上Play framework的文档地址，官方有更为详尽的功能叙述。Play framework文档\n项目构成 play framework的初始化非常简单，只要下载了play的软件包后，在命令行中运行play new xxx即可初始化一个项目。 自动生成的项目结构如下：\n运行play程序也非常简单，在项目目录下使用\nplay run 即可运行。\n启动脚本解析 play framework软件包目录 为了更好的了解play framework的运作原理，我们来从play framework的启动脚本开始分析，分析启动脚本有助于我们了解play framework的运行过程。\nplay的启动脚本是使用python编写的，脚本的入口为play软件包根目录下的play文件,下面我们将从play这个脚本的主入口开始分析。\nplay脚本解析 play脚本在开头引入了3个类，分别为play.cmdloader,play.application,play.utils，从添加的系统参数中可以看出play启动脚本的存放路径为 framework/pym cmdloader.py的主要作用为加载framework/pym/commands下的各个脚本文件，用于之后对命令参数的解释运行 application.py的主要作用为解析项目路径下conf/中的配置文件、加载模块、拼接最后运行的java命令\nsys.path.append(os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), \u0026#39;framework\u0026#39;, \u0026#39;pym\u0026#39;)) from play.cmdloader import CommandLoader from play.application import PlayApplication from play.utils import * 在脚本的开头，有这么一段代码，意味着只要在play主程序根目录下创建一个名为id的文件，即可设置默认的框架id\nplay_env[\u0026#34;id_file\u0026#34;] = os.path.join(play_env[\u0026#39;basedir\u0026#39;], \u0026#39;id\u0026#39;) if os.path.exists(play_env[\u0026#34;id_file\u0026#34;]): play_env[\u0026#34;id\u0026#34;] = open(play_env[\u0026#34;id_file\u0026#34;]).readline().strip() else: play_env[\u0026#34;id\u0026#34;] = \u0026#39;\u0026#39; 命令参数的分隔由以下代码完成，例如使用了play run \u0026ndash;%test,那么参数列表就是\n[\u0026ldquo;xxxx\\play\u0026rdquo;,\u0026ldquo;run\u0026rdquo;,\u0026quot;\u0026ndash;%test\u0026quot;]\n这段代码也说明了，play的命令格式为\nplay cmd [app_path] [\u0026ndash;options]\n","keywords":["program","backend"],"articleBody":"注：本系列文章所用play版本为1.2.6\n介绍 Play framework是个轻量级的RESTful框架，致力于让java程序员实现快速高效开发，它具有以下几个方面的优势：\n热加载。在调试模式下，所有修改会及时生效。 抛弃xml配置文件。约定大于配置。 支持异步编程 无状态mvc框架，拓展性良好 简单的路由设置 这里附上Play framework的文档地址，官方有更为详尽的功能叙述。Play framework文档\n项目构成 play framework的初始化非常简单，只要下载了play的软件包后，在命令行中运行play new xxx即可初始化一个项目。 自动生成的项目结构如下：\n运行play程序也非常简单，在项目目录下使用\nplay run 即可运行。\n启动脚本解析 play framework软件包目录 为了更好的了解play framework的运作原理，我们来从play framework的启动脚本开始分析，分析启动脚本有助于我们了解play framework的运行过程。\nplay的启动脚本是使用python编写的，脚本的入口为play软件包根目录下的play文件,下面我们将从play这个脚本的主入口开始分析。\nplay脚本解析 play脚本在开头引入了3个类，分别为play.cmdloader,play.application,play.utils，从添加的系统参数中可以看出play启动脚本的存放路径为 framework/pym cmdloader.py的主要作用为加载framework/pym/commands下的各个脚本文件，用于之后对命令参数的解释运行 application.py的主要作用为解析项目路径下conf/中的配置文件、加载模块、拼接最后运行的java命令\nsys.path.append(os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'framework', 'pym')) from play.cmdloader import CommandLoader from play.application import PlayApplication from play.utils import * 在脚本的开头，有这么一段代码，意味着只要在play主程序根目录下创建一个名为id的文件，即可设置默认的框架id\nplay_env[\"id_file\"] = os.path.join(play_env['basedir'], 'id') if os.path.exists(play_env[\"id_file\"]): play_env[\"id\"] = open(play_env[\"id_file\"]).readline().strip() else: play_env[\"id\"] = '' 命令参数的分隔由以下代码完成，例如使用了play run –%test,那么参数列表就是\n[“xxxx\\play”,“run”,\"–%test\"]\n这段代码也说明了，play的命令格式为\nplay cmd [app_path] [–options]\napplication_path = None remaining_args = [] if len(sys.argv) == 1: application_path = os.getcwd() if len(sys.argv) == 2: application_path = os.getcwd() remaining_args = sys.argv[2:] if len(sys.argv) \u003e 2: if sys.argv[2].startswith('-'): application_path = os.getcwd() remaining_args = sys.argv[2:] else: application_path = os.path.normpath(os.path.abspath(sys.argv[2])) remaining_args = sys.argv[3:] 在play参数中，有一个ignoreMissing，这个参数的全称其实是ignoreMissingModules，作用就是在当配置文件中配置有模块但是在play目录下并没有找到时是否忽略，如需忽略那么在启动时需要加入--force\nignoreMissing = False if remaining_args.count('--force') == 1: remaining_args.remove('--force') ignoreMissing = True 脚本通过\nplay_app = PlayApplication(application_path, play_env, ignoreMissing)\n和\ncmdloader = CommandLoader(play_env[“basedir”])\n来进行PlayApplication类和CommandLoader类的初始化。 在PlayApplication类的初始化过程中，它创建了PlayConfParser类用来解析配置文件，这也就是说play的配置文件解析是在脚本启动阶段进行的，这也是为什么修改配置文件无法实时生效需要重启的原因\n在PlayConfParser中有一个常量DEFAULTS储存了默认的http端口和jpda调试端口，分别为9000和8000，需要添加默认值可以修改DEFAULTS，DEFAULTS内的值只有当配置文件中找不到时才会生效。\nDEFAULTS = { 'http.port': '9000', 'jpda.port': '8000' } 值得一提的是，配置文件中的http.port的优先级是小于命令参数中的http.port的\n#env为命令参数 if env.has_key('http.port'): self.entries['http.port'] = env['http.port'] CommandLoader类的功能很简单，就是遍历framework/pym/commands下的.py文件，依次加载然后读取他的全局变量COMMANDS和MODULE储存用于之后的命令处理和模块加载。\n回到play脚本中，在PlayApplication类和CommandLoader类初始化完成之后，play进行\"–deps\"参数的检查，如果存在–deps，则调用play.deps.DependenciesManager类来进行依赖的检查、更新。DependenciesManager的解析将放到后话详解。\nif remaining_args.count('--deps') == 1: cmdloader.commands['dependencies'].execute(command='dependencies', app=play_app, args=['--sync'], env=play_env, cmdloader=cmdloader) remaining_args.remove('--deps') 接下来，play便正式进行启动过程，play按照以下的顺序进行加载：\n加载配置文件中记录的模块的命令信息 加载参数中指定的模块的命令信息 运行各模块中的before函数 执行play_command,play_command即为run,test,war等play需要的执行的命令 运行各模块中的after函数 结束脚本 if play_command in cmdloader.commands: for name in cmdloader.modules: module = cmdloader.modules[name] if 'before' in dir(module): module.before(command=play_command, app=play_app, args=remaining_args, env=play_env) status = cmdloader.commands[play_command].execute(command=play_command, app=play_app, args=remaining_args, env=play_env, cmdloader=cmdloader) for name in cmdloader.modules: module = cmdloader.modules[name] if 'after' in dir(module): module.after(command=play_command, app=play_app, args=remaining_args, env=play_env) sys.exit(status) 下面，我们来看看play常用命令的运行过程…\nPlay常用运行命令解析 在本节的一开始，我决定先把play所有的可用命令先列举一下，以便读者可以选择性阅读。\n命令名称 命令所在文件 作用 antify ant.py 初始化ant构建工具的build.xml文件 run base.py 运行程序 new base.py 新建play应用 clean base.py 删除临时文件，即清空tmp文件夹 test base.py 运行测试程序 autotest、auto-test base.py 自动运行所有测试项目 id base.py 设置项目id new,run base.py 新建play应用并启动 clean,run base.py 删除临时文件并运行 modules base.py 显示项目用到的模块，注：这里显示的模块只是在项目配置文件中引用的模块，命令参数中添加的模块不会显示 check check.py 检查play更新 classpath、cp classpath.py 显示应用的classpath start daemon.py 在后台运行play程序 stop daemon.py 停止正在运行的程序 restart daemon.py 重启正在运行的程序 pid daemon.py 显示运行中的程序的pid out daemon.py 显示输出 dependencies、deps deps.py 运行DependenciesManager更新依赖 eclipsify、ec eclipse.py 创建eclipse配置文件 evolutions evolutions.py 运行play.db.Evolutions进行数据库演变检查 help help.py 输出所有play的可用命令 idealize、idea intellij.py 生成idea配置文件 javadoc javadoc.py 生成javadoc new-module、nm modulesrepo.py 创建新模块 list-modules、lm modulesrepo.py 显示play社区中的模块 build-module、bm modulesrepo.py 打包模块 add modulesrepo.py 将模块添加至项目 install modulesrepo.py 安装模块 netbeansify netbeans.py 生成netbeans配置文件 precompile precompile.py 预编译 secret secret.py 生成secret key status status.py 显示运行中项目的状态 version version.py 显示play framework的版本号 war war.py 将项目打包为war文件 run与start run应该是我们平时用的最多的命令了，run命令的作用其实很简单，就是根据命令参数拼接java参数，然后调用java来运行play.server.Server，run函数的代码如下:\ndef run(app, args): #app即为play脚本中创建的PlayApplication类 global process #这里检查是否存在conf/routes和conf/application.conf app.check() print \"~ Ctrl+C to stop\" print \"~ \" java_cmd = app.java_cmd(args) try: process = subprocess.Popen (java_cmd, env=os.environ) signal.signal(signal.SIGTERM, handle_sigterm) return_code = process.wait() signal.signal(signal.SIGINT, handle_sigint) if 0 != return_code: sys.exit(return_code) except OSError: print \"Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). \" sys.exit(-1) print app.java_cmd(args)的实现代码如下：\ndef java_cmd(self, java_args, cp_args=None, className='play.server.Server', args = None): if args is None: args = [''] memory_in_args=False #检查java参数中是否有jvm内存设置 for arg in java_args: if arg.startswith('-Xm'): memory_in_args=True #如果参数中无jvm内存设置，那么在配置文件中找是否有jvm内存设置，若还是没有则在环境变量中找是否有JAVA_OPTS #这里其实有个问题，这里假定的是JAVA_OPTS变量里只存了jvm内存设置，如果JAVA_OPTS还存了其他选项，那对运行可能有影响 if not memory_in_args: memory = self.readConf('jvm.memory') if memory: java_args = java_args + memory.split(' ') elif 'JAVA_OPTS' in os.environ: java_args = java_args + os.environ['JAVA_OPTS'].split(' ') #获取程序的classpath if cp_args is None: cp_args = self.cp_args() #读取配置文件中的jpda端口 self.jpda_port = self.readConf('jpda.port') #读取配置文件中的运行模式 application_mode = self.readConf('application.mode').lower() #如果模式是prod，则用server模式编译 if application_mode == 'prod': java_args.append('-server') # JDK 7 compat # 使用新class校验器 (不知道作用) java_args.append('-XX:-UseSplitVerifier') #查找配置文件中是否有java安全配置，如果有则加入java参数中 java_policy = self.readConf('java.policy') if java_policy != '': policyFile = os.path.join(self.path, 'conf', java_policy) if os.path.exists(policyFile): print \"~ using policy file \\\"%s\\\"\" % policyFile java_args.append('-Djava.security.manager') java_args.append('-Djava.security.policy==%s' % policyFile) #加入http端口设置 if self.play_env.has_key('http.port'): args += [\"--http.port=%s\" % self.play_env['http.port']] #加入https端口设置 if self.play_env.has_key('https.port'): args += [\"--https.port=%s\" % self.play_env['https.port']] #设置文件编码 java_args.append('-Dfile.encoding=utf-8') #设置编译命令 (这边使用了jregex/Pretokenizer类的next方法，不知道有什么用) java_args.append('-XX:CompileCommand=exclude,jregex/Pretokenizer,next') #如果程序模式在dev，则添加jpda调试器参数 if self.readConf('application.mode').lower() == 'dev': if not self.play_env[\"disable_check_jpda\"]: self.check_jpda() java_args.append('-Xdebug') java_args.append('-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n' % self.jpda_port) java_args.append('-Dplay.debug=yes') #拼接java参数 java_cmd = [self.java_path(), '-javaagent:%s' % self.agent_path()] + java_args + ['-classpath', cp_args, '-Dapplication.path=%s' % self.path, '-Dplay.id=%s' % self.play_env[\"id\"], className] + args return java_cmd start命令与run命令很类似，执行步骤为：\n依次查找play变量pid_file、系统环境变量PLAY_PID_PATH、项目根目录下server.pid，查找是否存在指定pid 若第一步找到pid，查找当前进程列表中是否存在此pid进程，存在则试图关闭进程。(如果此时pid已经不是play的进程呢😅) 在配置文件中找application.log.system.out看是否关闭了系统输出 启动程序，这里与run命令唯一的区别就是他指定了stdout位置，这样就变成了后台程序 将启动后的程序的pid写入server.pid stop命令即关闭当前进程，这里要提一下，play有个注解叫OnApplicationStop，即会在程序停止时触发，而OnApplicationStop的实现主要是调用了\nRuntime.getRuntime().addShutdownHook();\n来完成\ntest与autotest 使用play test命令可以让程序进入测试模式，test命令和run命令其实差别不大，唯一的区别就在于使用test命令时，脚本会将play id自动替换为test，当play id为test时会自动引入testrunner模块，testrunner模块主要功能为添加@tests路由并实现了test测试页面，他的具体实现过程后续再谈。 autotest命令的作用是自动测试所有的测试用例，他的执行顺序是这样的：\n检查是否存在tmp文件夹，存在即删除 检查是否有程序正在运行，如存在则关闭程序 检查程序是否配置了ssl但是没有指定证书 检查是否存在test-result文件夹，存在即删除 使用test作为id重启程序 调用play.modules.testrunner.FirePhoque来进行自动化测试 关闭程序 autotest的脚本的步骤1和2我觉得是有问题的，应该换下顺序，不然如果程序正在向tmp文件夹插入临时文件，那么tmp文件夹就删除失败了。 关闭程序的代码调用了http://localhost:%http_port/@kill进行关闭，@kill的实现方法在play.CorePlugin下，注意，@kill在prod模式下无效 (这是废话)\n由于使用了python作为启动脚本，无法通过java内部变量值判断程序是否开启，只能查看控制台的输出日志，所以在使用test作为id重启后，脚本使用下面的代码判断程序是否完全启动：\ntry: #这里启动程序 play_process = subprocess.Popen(java_cmd, env=os.environ, stdout=sout) except OSError: print \"Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). \" sys.exit(-1) #打开日志输出文件 soutint = open(os.path.join(app.log_path(), 'system.out'), 'r') while True: if play_process.poll(): print \"~\" print \"~ Oops, application has not started?\" print \"~\" sys.exit(-1) line = soutint.readline().strip() if line: print line #若出现'Server is up and running'则正常启动 if line.find('Server is up and running') \u003e -1: # This line is written out by Server.java to system.out and is not log file dependent soutint.close() break FirePhoque类的实现过程我们之后再详解。\nnew与clean 我们使用new来创建一个新项目，play new的使用方法为play new project-name [--with] [--name]。 with参数为项目所使用的模块。 name为项目名，这里要注意一点，project-name和–name的参数可以设置为不同值，project-name是项目建立的文件夹名，–name的值为项目配置文件中的application.name。\n如果不加–name，脚本会提示你是否使用project-name作为名字，在确认之后，脚本会将resources/application-skel中的所有文件拷贝到{project-name}文件夹下，然后用输入的name替换项目配置文件下的application.name，并生成一个64位的secretKey替换配置文件中的secretKey。\n接着，脚本会查找使用的模块中是否存在dependencies.yml，并将dependencies.yml中的内容加入项目的dependencies.yml中，并调用DependenciesManager检查依赖状态。\nnew函数的主要代码如下:\nprint \"~ The new application will be created in %s\" % os.path.normpath(app.path) if application_name is None: application_name = raw_input(\"~ What is the application name? [%s] \" % os.path.basename(app.path)) if application_name == \"\": application_name = os.path.basename(app.path) copy_directory(os.path.join(env[\"basedir\"], 'resources/application-skel'), app.path) os.mkdir(os.path.join(app.path, 'app/models')) os.mkdir(os.path.join(app.path, 'lib')) app.check() replaceAll(os.path.join(app.path, 'conf/application.conf'), r'%APPLICATION_NAME%', application_name) replaceAll(os.path.join(app.path, 'conf/application.conf'), r'%SECRET_KEY%', secretKey()) print \"~\" clean命令非常简单，就是删除整个tmp文件夹\nwar与precompile 很多时候，我们需要使用tomcat等服务器容器作为服务载体，这时候就需要将play应用打包为war\nwar的使用参数是\nplay war project-name [-o/–output][filename] [–zip] [–exclude][exclude-directories]\n使用-o或–output来指定输出文件夹，使用–zip压缩为war格式，使用–exclude来包含另外需要打包的文件夹\n要注意的是，必须在项目目录外进行操作，不然会失败\n在参数处理完毕后，脚本正式开始打包过程，分为2个步骤：1.预编译。2：打包\n预编译即用到了precompile命令，precompile命令与run命令几乎一样，只是在java参数中加入了precompile=yes\n让我们来看一下加入了这个java参数对程序的影响。 与预编译有关的代码主要是下面2段：\nstatic boolean preCompile() { if (usePrecompiled) { if (Play.getFile(\"precompiled\").exists()) { classloader.getAllClasses(); Logger.info(\"Application is precompiled\"); return true; } Logger.error(\"Precompiled classes are missing!!\"); fatalServerErrorOccurred(); return false; } //这里开始预编译 try { Logger.info(\"Precompiling ...\"); Thread.currentThread().setContextClassLoader(Play.classloader); long start = System.currentTimeMillis(); //getAllClasses方法较长，就不贴了，下面一段代码在getAllClasses方法中进入 classloader.getAllClasses(); if (Logger.isTraceEnabled()) { Logger.trace(\"%sms to precompile the Java stuff\", System.currentTimeMillis() - start); } if (!lazyLoadTemplates) { start = System.currentTimeMillis(); //编译模板 TemplateLoader.getAllTemplate(); if (Logger.isTraceEnabled()) { Logger.trace(\"%sms to precompile the templates\", System.currentTimeMillis() - start); } } return true; } catch (Throwable e) { Logger.error(e, \"Cannot start in PROD mode with errors\"); fatalServerErrorOccurred(); return false; } } public byte[] enhance() { this.enhancedByteCode = this.javaByteCode; if (isClass()) { // before we can start enhancing this class we must make sure it is not a PlayPlugin. // PlayPlugins can be included as regular java files in a Play-application. // If a PlayPlugin is present in the application, it is loaded when other plugins are loaded. // All plugins must be loaded before we can start enhancing. // This is a problem when loading PlayPlugins bundled as regular app-class since it uses the same classloader // as the other (soon to be) enhanched play-app-classes. boolean shouldEnhance = true; try { CtClass ctClass = enhanceChecker_classPool.makeClass(new ByteArrayInputStream(this.enhancedByteCode)); if (ctClass.subclassOf(ctPlayPluginClass)) { shouldEnhance = false; } } catch( Exception e) { // nop } if (shouldEnhance) { Play.pluginCollection.enhance(this); } } //主要是这一段，他将增强处理后的字节码写入了文件，增强处理在之后会深入展开 if (System.getProperty(\"precompile\") != null) { try { // emit bytecode to standard class layout as well File f = Play.getFile(\"precompiled/java/\" + (name.replace(\".\", \"/\")) + \".class\"); f.getParentFile().mkdirs(); FileOutputStream fos = new FileOutputStream(f); fos.write(this.enhancedByteCode); fos.close(); } catch (Exception e) { e.printStackTrace(); } } return this.enhancedByteCode; } 预编译过程结束后，脚本正式开始打包过程，打包过程比较简单，就是讲预编译后的字节码文件、模板文件、配置文件、使用的类库、使用的模块类库等移动至WEB-INF文件夹中，如果使用了–zip，那么脚本会将生成的文件夹用zip格式打包。\nsecret和status secret命令能生成一个新的secret key status命令是用于实时显示程序的运行状态，脚本的运作十分简单，步骤如下：\n检查是否有–url参数，有则在他之后添加@status 检查是否存在–secret 如果没有–url，则使用http://localhost:%http_port/@status;如果没有 –secret，则从配置文件中读取secret key 将secret_key、’@status’使用sha加密，并加入Authorization请求头 发送请求 @status的实现和@kill一样在CorePlugin类中，这在之后再进行详解。\n总结 Play的启动脚本分析至此就结束了，从脚本的分析过程中我们可以稍微探究下Play在脚本启动阶段有何行为，这对我们进行脚本改造或者启动优化还是非常有帮助的。 下一篇，我们来看看Play的启动类是如何运作的。。\n","wordCount":"1041","inLanguage":"en","image":"https://example.org/avatar.png","datePublished":"2018-01-03T13:56:21Z","dateModified":"2018-01-03T13:56:21Z","author":{"@type":"Person","name":"luyanliang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://example.org/posts/play-framework/part1-play-framework-%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90/"},"publisher":{"@type":"Organization","name":"404 NOT FOUND","logo":{"@type":"ImageObject","url":"https://example.org/avatar.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://example.org/ accesskey=h title="404 NOT FOUND (Alt + H)">404 NOT FOUND</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://example.org/posts/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://example.org/>Home</a>&nbsp;»&nbsp;<a href=https://example.org/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Play framework源码解析 Part1: Play framework 介绍、项目构成及启动脚本解析</h1><div class=post-meta><span title='2018-01-03 13:56:21 +0000 UTC'>January 3, 2018</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1041 words&nbsp;·&nbsp;luyanliang</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#play-framework软件包目录>play framework软件包目录</a></li><li><a href=#play脚本解析>play脚本解析</a></li><li><a href=#play常用运行命令解析>Play常用运行命令解析</a><ul><li><a href=#run与start>run与start</a></li><li><a href=#test与autotest>test与autotest</a></li><li><a href=#new与clean>new与clean</a></li><li><a href=#war与precompile>war与precompile</a></li><li><a href=#secret和status>secret和status</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p><font color=#DC143C>注：本系列文章所用play版本为1.2.6</font></p><hr><h1 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h1><p>Play framework是个轻量级的RESTful框架，致力于让java程序员实现快速高效开发，它具有以下几个方面的优势：</p><ol><li>热加载。在调试模式下，所有修改会及时生效。</li><li>抛弃xml配置文件。约定大于配置。</li><li>支持异步编程</li><li>无状态mvc框架，拓展性良好</li><li>简单的路由设置</li></ol><p>这里附上Play framework的文档地址，官方有更为详尽的功能叙述。<a href=https://www.playframework.com/documentation/1.2.x/overview title=文档>Play framework文档</a></p><hr><h1 id=项目构成>项目构成<a hidden class=anchor aria-hidden=true href=#项目构成>#</a></h1><p>play framework的初始化非常简单，只要下载了play的软件包后，在命令行中运行play new xxx即可初始化一个项目。
自动生成的项目结构如下：</p><p><img alt=play项目结构 loading=lazy src=https://i.loli.net/2018/01/08/5a53879bec91f.png></p><p>运行play程序也非常简单，在项目目录下使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>play run
</span></span></code></pre></div><p>即可运行。</p><hr><h1 id=启动脚本解析>启动脚本解析<a hidden class=anchor aria-hidden=true href=#启动脚本解析>#</a></h1><h2 id=play-framework软件包目录>play framework软件包目录<a hidden class=anchor aria-hidden=true href=#play-framework软件包目录>#</a></h2><p>为了更好的了解play framework的运作原理，我们来从play framework的启动脚本开始分析，分析启动脚本有助于我们了解play framework的运行过程。</p><p>play的启动脚本是使用python编写的，脚本的入口为play软件包根目录下的play文件,下面我们将从play这个脚本的主入口开始分析。</p><p><img alt=play项目结构 loading=lazy src=https://i.loli.net/2018/01/08/5a5386dfdfdb6.png></p><h2 id=play脚本解析>play脚本解析<a hidden class=anchor aria-hidden=true href=#play脚本解析>#</a></h2><p>play脚本在开头引入了3个类，分别为play.cmdloader,play.application,play.utils，从添加的系统参数中可以看出play启动脚本的存放路径为 framework/pym
cmdloader.py的主要作用为加载framework/pym/commands下的各个脚本文件，用于之后对命令参数的解释运行
application.py的主要作用为解析项目路径下conf/中的配置文件、加载模块、拼接最后运行的java命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sys<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>append(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>dirname(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>realpath(sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>0</span>])), <span style=color:#e6db74>&#39;framework&#39;</span>, <span style=color:#e6db74>&#39;pym&#39;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> play.cmdloader <span style=color:#f92672>import</span> CommandLoader
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> play.application <span style=color:#f92672>import</span> PlayApplication
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> play.utils <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span></code></pre></div><p>在脚本的开头，有这么一段代码，意味着只要在play主程序根目录下创建一个名为id的文件，即可设置默认的框架id</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>play_env[<span style=color:#e6db74>&#34;id_file&#34;</span>] <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(play_env[<span style=color:#e6db74>&#39;basedir&#39;</span>], <span style=color:#e6db74>&#39;id&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(play_env[<span style=color:#e6db74>&#34;id_file&#34;</span>]):
</span></span><span style=display:flex><span>    play_env[<span style=color:#e6db74>&#34;id&#34;</span>] <span style=color:#f92672>=</span> open(play_env[<span style=color:#e6db74>&#34;id_file&#34;</span>])<span style=color:#f92672>.</span>readline()<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    play_env[<span style=color:#e6db74>&#34;id&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span></code></pre></div><p>命令参数的分隔由以下代码完成，例如使用了play run &ndash;%test,那么参数列表就是</p><blockquote><p>[&ldquo;xxxx\play&rdquo;,&ldquo;run&rdquo;,"&ndash;%test"]</p></blockquote><p>这段代码也说明了，play的命令格式为</p><blockquote><p>play cmd [app_path] [&ndash;options]</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>application_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>remaining_args <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> len(sys<span style=color:#f92672>.</span>argv) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>    application_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>getcwd()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> len(sys<span style=color:#f92672>.</span>argv) <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>    application_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>getcwd()
</span></span><span style=display:flex><span>    remaining_args <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> len(sys<span style=color:#f92672>.</span>argv) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>2</span>]<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;-&#39;</span>):
</span></span><span style=display:flex><span>        application_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>getcwd()
</span></span><span style=display:flex><span>        remaining_args <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        application_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>normpath(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>abspath(sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>2</span>]))
</span></span><span style=display:flex><span>        remaining_args <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>3</span>:]
</span></span></code></pre></div><p>在play参数中，有一个ignoreMissing，这个参数的全称其实是ignoreMissingModules，作用就是在当配置文件中配置有模块但是在play目录下并没有找到时是否忽略，如需忽略那么在启动时需要加入<code>--force</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ignoreMissing <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> remaining_args<span style=color:#f92672>.</span>count(<span style=color:#e6db74>&#39;--force&#39;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>    remaining_args<span style=color:#f92672>.</span>remove(<span style=color:#e6db74>&#39;--force&#39;</span>)
</span></span><span style=display:flex><span>    ignoreMissing <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p>脚本通过</p><blockquote><p>play_app = PlayApplication(application_path, play_env, ignoreMissing)</p></blockquote><p>和</p><blockquote><p>cmdloader = CommandLoader(play_env[&ldquo;basedir&rdquo;])</p></blockquote><p>来进行PlayApplication类和CommandLoader类的初始化。
在PlayApplication类的初始化过程中，它创建了PlayConfParser类用来解析配置文件，这也就是说play的配置文件解析是在脚本启动阶段进行的，<strong>这也是为什么修改配置文件无法实时生效需要重启的原因</strong><br>在PlayConfParser中有一个常量DEFAULTS储存了默认的http端口和jpda调试端口，分别为9000和8000，需要添加默认值可以修改DEFAULTS，DEFAULTS内的值只有当配置文件中找不到时才会生效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>DEFAULTS <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;http.port&#39;</span>: <span style=color:#e6db74>&#39;9000&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;jpda.port&#39;</span>: <span style=color:#e6db74>&#39;8000&#39;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>值得一提的是，配置文件中的http.port的优先级是小于命令参数中的http.port的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#env为命令参数</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> env<span style=color:#f92672>.</span>has_key(<span style=color:#e6db74>&#39;http.port&#39;</span>):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>entries[<span style=color:#e6db74>&#39;http.port&#39;</span>] <span style=color:#f92672>=</span> env[<span style=color:#e6db74>&#39;http.port&#39;</span>]
</span></span></code></pre></div><p>CommandLoader类的功能很简单，就是遍历framework/pym/commands下的.py文件，依次加载然后读取他的全局变量COMMANDS和MODULE储存用于之后的命令处理和模块加载。</p><p>回到play脚本中，在PlayApplication类和CommandLoader类初始化完成之后，play进行"&ndash;deps"参数的检查，如果存在&ndash;deps，则调用play.deps.DependenciesManager类来进行依赖的检查、更新。DependenciesManager的解析将放到后话详解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> remaining_args<span style=color:#f92672>.</span>count(<span style=color:#e6db74>&#39;--deps&#39;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>    cmdloader<span style=color:#f92672>.</span>commands[<span style=color:#e6db74>&#39;dependencies&#39;</span>]<span style=color:#f92672>.</span>execute(command<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;dependencies&#39;</span>, app<span style=color:#f92672>=</span>play_app, args<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;--sync&#39;</span>], env<span style=color:#f92672>=</span>play_env, cmdloader<span style=color:#f92672>=</span>cmdloader)
</span></span><span style=display:flex><span>    remaining_args<span style=color:#f92672>.</span>remove(<span style=color:#e6db74>&#39;--deps&#39;</span>)
</span></span></code></pre></div><p>接下来，play便正式进行启动过程，play按照以下的顺序进行加载：</p><ol><li>加载配置文件中记录的模块的命令信息</li><li>加载参数中指定的模块的命令信息</li><li>运行各模块中的before函数</li><li>执行play_command,play_command即为run,test,war等play需要的执行的命令</li><li>运行各模块中的after函数</li><li>结束脚本</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> play_command <span style=color:#f92672>in</span> cmdloader<span style=color:#f92672>.</span>commands:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> name <span style=color:#f92672>in</span> cmdloader<span style=color:#f92672>.</span>modules:
</span></span><span style=display:flex><span>        module <span style=color:#f92672>=</span> cmdloader<span style=color:#f92672>.</span>modules[name]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;before&#39;</span> <span style=color:#f92672>in</span> dir(module):
</span></span><span style=display:flex><span>            module<span style=color:#f92672>.</span>before(command<span style=color:#f92672>=</span>play_command, app<span style=color:#f92672>=</span>play_app, args<span style=color:#f92672>=</span>remaining_args, env<span style=color:#f92672>=</span>play_env)
</span></span><span style=display:flex><span>    status <span style=color:#f92672>=</span> cmdloader<span style=color:#f92672>.</span>commands[play_command]<span style=color:#f92672>.</span>execute(command<span style=color:#f92672>=</span>play_command, app<span style=color:#f92672>=</span>play_app, args<span style=color:#f92672>=</span>remaining_args, env<span style=color:#f92672>=</span>play_env, cmdloader<span style=color:#f92672>=</span>cmdloader)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> name <span style=color:#f92672>in</span> cmdloader<span style=color:#f92672>.</span>modules:
</span></span><span style=display:flex><span>        module <span style=color:#f92672>=</span> cmdloader<span style=color:#f92672>.</span>modules[name]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;after&#39;</span> <span style=color:#f92672>in</span> dir(module):
</span></span><span style=display:flex><span>            module<span style=color:#f92672>.</span>after(command<span style=color:#f92672>=</span>play_command, app<span style=color:#f92672>=</span>play_app, args<span style=color:#f92672>=</span>remaining_args, env<span style=color:#f92672>=</span>play_env)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>exit(status)
</span></span></code></pre></div><p>下面，我们来看看play常用命令的运行过程&mldr;</p><h2 id=play常用运行命令解析>Play常用运行命令解析<a hidden class=anchor aria-hidden=true href=#play常用运行命令解析>#</a></h2><p>在本节的一开始，我决定先把play所有的可用命令先列举一下，以便读者可以选择性阅读。</p><table><thead><tr><th>命令名称</th><th>命令所在文件</th><th>作用</th></tr></thead><tbody><tr><td>antify</td><td>ant.py</td><td>初始化ant构建工具的build.xml文件</td></tr><tr><td>run</td><td>base.py</td><td>运行程序</td></tr><tr><td>new</td><td>base.py</td><td>新建play应用</td></tr><tr><td>clean</td><td>base.py</td><td>删除临时文件，即清空tmp文件夹</td></tr><tr><td>test</td><td>base.py</td><td>运行测试程序</td></tr><tr><td>autotest、auto-test</td><td>base.py</td><td>自动运行所有测试项目</td></tr><tr><td>id</td><td>base.py</td><td>设置项目id</td></tr><tr><td>new,run</td><td>base.py</td><td>新建play应用并启动</td></tr><tr><td>clean,run</td><td>base.py</td><td>删除临时文件并运行</td></tr><tr><td>modules</td><td>base.py</td><td>显示项目用到的模块，注：这里显示的模块只是在项目配置文件中引用的模块，命令参数中添加的模块不会显示</td></tr><tr><td>check</td><td>check.py</td><td>检查play更新</td></tr><tr><td>classpath、cp</td><td>classpath.py</td><td>显示应用的classpath</td></tr><tr><td>start</td><td>daemon.py</td><td>在后台运行play程序</td></tr><tr><td>stop</td><td>daemon.py</td><td>停止正在运行的程序</td></tr><tr><td>restart</td><td>daemon.py</td><td>重启正在运行的程序</td></tr><tr><td>pid</td><td>daemon.py</td><td>显示运行中的程序的pid</td></tr><tr><td>out</td><td>daemon.py</td><td>显示输出</td></tr><tr><td>dependencies、deps</td><td>deps.py</td><td>运行DependenciesManager更新依赖</td></tr><tr><td>eclipsify、ec</td><td>eclipse.py</td><td>创建eclipse配置文件</td></tr><tr><td>evolutions</td><td>evolutions.py</td><td>运行play.db.Evolutions进行数据库演变检查</td></tr><tr><td>help</td><td>help.py</td><td>输出所有play的可用命令</td></tr><tr><td>idealize、idea</td><td>intellij.py</td><td>生成idea配置文件</td></tr><tr><td>javadoc</td><td>javadoc.py</td><td>生成javadoc</td></tr><tr><td>new-module、nm</td><td>modulesrepo.py</td><td>创建新模块</td></tr><tr><td>list-modules、lm</td><td>modulesrepo.py</td><td>显示play社区中的模块</td></tr><tr><td>build-module、bm</td><td>modulesrepo.py</td><td>打包模块</td></tr><tr><td>add</td><td>modulesrepo.py</td><td>将模块添加至项目</td></tr><tr><td>install</td><td>modulesrepo.py</td><td>安装模块</td></tr><tr><td>netbeansify</td><td>netbeans.py</td><td>生成netbeans配置文件</td></tr><tr><td>precompile</td><td>precompile.py</td><td>预编译</td></tr><tr><td>secret</td><td>secret.py</td><td>生成secret key</td></tr><tr><td>status</td><td>status.py</td><td>显示运行中项目的状态</td></tr><tr><td>version</td><td>version.py</td><td>显示play framework的版本号</td></tr><tr><td>war</td><td>war.py</td><td>将项目打包为war文件</td></tr></tbody></table><h3 id=run与start>run与start<a hidden class=anchor aria-hidden=true href=#run与start>#</a></h3><p>run应该是我们平时用的最多的命令了，run命令的作用其实很简单，就是根据命令参数拼接java参数，然后调用java来运行play.server.Server，run函数的代码如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(app, args):
</span></span><span style=display:flex><span>    <span style=color:#75715e>#app即为play脚本中创建的PlayApplication类</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> process
</span></span><span style=display:flex><span>    <span style=color:#75715e>#这里检查是否存在conf/routes和conf/application.conf</span>
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>check()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print <span style=color:#e6db74>&#34;~ Ctrl+C to stop&#34;</span>
</span></span><span style=display:flex><span>    print <span style=color:#e6db74>&#34;~ &#34;</span>
</span></span><span style=display:flex><span>    java_cmd <span style=color:#f92672>=</span> app<span style=color:#f92672>.</span>java_cmd(args)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        process <span style=color:#f92672>=</span> subprocess<span style=color:#f92672>.</span>Popen (java_cmd, env<span style=color:#f92672>=</span>os<span style=color:#f92672>.</span>environ)
</span></span><span style=display:flex><span>        signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGTERM, handle_sigterm)
</span></span><span style=display:flex><span>        return_code <span style=color:#f92672>=</span> process<span style=color:#f92672>.</span>wait()
</span></span><span style=display:flex><span>    signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGINT, handle_sigint)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>!=</span> return_code:
</span></span><span style=display:flex><span>            sys<span style=color:#f92672>.</span>exit(return_code)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>OSError</span>:
</span></span><span style=display:flex><span>        print <span style=color:#e6db74>&#34;Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). &#34;</span>
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print
</span></span></code></pre></div><p>app.java_cmd(args)的实现代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>java_cmd</span>(self, java_args, cp_args<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, className<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;play.server.Server&#39;</span>, args <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> args <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        args <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;&#39;</span>]
</span></span><span style=display:flex><span>    memory_in_args<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#检查java参数中是否有jvm内存设置</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> arg <span style=color:#f92672>in</span> java_args:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> arg<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;-Xm&#39;</span>):
</span></span><span style=display:flex><span>            memory_in_args<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#如果参数中无jvm内存设置，那么在配置文件中找是否有jvm内存设置，若还是没有则在环境变量中找是否有JAVA_OPTS</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#这里其实有个问题，这里假定的是JAVA_OPTS变量里只存了jvm内存设置，如果JAVA_OPTS还存了其他选项，那对运行可能有影响</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> memory_in_args:
</span></span><span style=display:flex><span>        memory <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>readConf(<span style=color:#e6db74>&#39;jvm.memory&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> memory:
</span></span><span style=display:flex><span>            java_args <span style=color:#f92672>=</span> java_args <span style=color:#f92672>+</span> memory<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39; &#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#e6db74>&#39;JAVA_OPTS&#39;</span> <span style=color:#f92672>in</span> os<span style=color:#f92672>.</span>environ:
</span></span><span style=display:flex><span>            java_args <span style=color:#f92672>=</span> java_args <span style=color:#f92672>+</span> os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#39;JAVA_OPTS&#39;</span>]<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39; &#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#获取程序的classpath</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> cp_args <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        cp_args <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>cp_args()
</span></span><span style=display:flex><span>    <span style=color:#75715e>#读取配置文件中的jpda端口</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>jpda_port <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>readConf(<span style=color:#e6db74>&#39;jpda.port&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#读取配置文件中的运行模式</span>
</span></span><span style=display:flex><span>    application_mode <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>readConf(<span style=color:#e6db74>&#39;application.mode&#39;</span>)<span style=color:#f92672>.</span>lower()
</span></span><span style=display:flex><span>    <span style=color:#75715e>#如果模式是prod，则用server模式编译</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> application_mode <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;prod&#39;</span>:
</span></span><span style=display:flex><span>        java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-server&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># JDK 7 compat</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 使用新class校验器 (不知道作用)</span>
</span></span><span style=display:flex><span>    java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-XX:-UseSplitVerifier&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#查找配置文件中是否有java安全配置，如果有则加入java参数中</span>
</span></span><span style=display:flex><span>    java_policy <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>readConf(<span style=color:#e6db74>&#39;java.policy&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> java_policy <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;&#39;</span>:
</span></span><span style=display:flex><span>        policyFile <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(self<span style=color:#f92672>.</span>path, <span style=color:#e6db74>&#39;conf&#39;</span>, java_policy)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(policyFile):
</span></span><span style=display:flex><span>            print <span style=color:#e6db74>&#34;~ using policy file </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> policyFile
</span></span><span style=display:flex><span>            java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-Djava.security.manager&#39;</span>)
</span></span><span style=display:flex><span>            java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-Djava.security.policy==</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> policyFile)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#加入http端口设置</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>play_env<span style=color:#f92672>.</span>has_key(<span style=color:#e6db74>&#39;http.port&#39;</span>):
</span></span><span style=display:flex><span>        args <span style=color:#f92672>+=</span> [<span style=color:#e6db74>&#34;--http.port=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>play_env[<span style=color:#e6db74>&#39;http.port&#39;</span>]]
</span></span><span style=display:flex><span>    <span style=color:#75715e>#加入https端口设置</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>play_env<span style=color:#f92672>.</span>has_key(<span style=color:#e6db74>&#39;https.port&#39;</span>):
</span></span><span style=display:flex><span>        args <span style=color:#f92672>+=</span> [<span style=color:#e6db74>&#34;--https.port=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>play_env[<span style=color:#e6db74>&#39;https.port&#39;</span>]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#设置文件编码</span>
</span></span><span style=display:flex><span>    java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-Dfile.encoding=utf-8&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#设置编译命令 (这边使用了jregex/Pretokenizer类的next方法，不知道有什么用)</span>
</span></span><span style=display:flex><span>    java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-XX:CompileCommand=exclude,jregex/Pretokenizer,next&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#如果程序模式在dev，则添加jpda调试器参数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>readConf(<span style=color:#e6db74>&#39;application.mode&#39;</span>)<span style=color:#f92672>.</span>lower() <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;dev&#39;</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>play_env[<span style=color:#e6db74>&#34;disable_check_jpda&#34;</span>]: self<span style=color:#f92672>.</span>check_jpda()
</span></span><span style=display:flex><span>        java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-Xdebug&#39;</span>)
</span></span><span style=display:flex><span>        java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-Xrunjdwp:transport=dt_socket,address=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>,server=y,suspend=n&#39;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>jpda_port)
</span></span><span style=display:flex><span>        java_args<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;-Dplay.debug=yes&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#拼接java参数</span>
</span></span><span style=display:flex><span>    java_cmd <span style=color:#f92672>=</span> [self<span style=color:#f92672>.</span>java_path(), <span style=color:#e6db74>&#39;-javaagent:</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>agent_path()] <span style=color:#f92672>+</span> java_args <span style=color:#f92672>+</span> [<span style=color:#e6db74>&#39;-classpath&#39;</span>, cp_args, <span style=color:#e6db74>&#39;-Dapplication.path=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>path, <span style=color:#e6db74>&#39;-Dplay.id=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>play_env[<span style=color:#e6db74>&#34;id&#34;</span>], className] <span style=color:#f92672>+</span> args
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> java_cmd
</span></span></code></pre></div><p>start命令与run命令很类似，执行步骤为：</p><ol><li>依次查找play变量pid_file、系统环境变量PLAY_PID_PATH、项目根目录下server.pid，查找是否存在指定pid</li><li>若第一步找到pid，查找当前进程列表中是否存在此pid进程，存在则试图关闭进程。(如果此时pid已经不是play的进程呢😅)</li><li>在配置文件中找application.log.system.out看是否关闭了系统输出</li><li>启动程序，这里与run命令唯一的区别就是他指定了stdout位置，这样就变成了后台程序</li><li>将启动后的程序的pid写入server.pid</li></ol><p>stop命令即关闭当前进程，这里要提一下，play有个注解叫OnApplicationStop，即会在程序停止时触发，而OnApplicationStop的实现主要是调用了</p><blockquote><p>Runtime.getRuntime().addShutdownHook();</p></blockquote><p>来完成</p><h3 id=test与autotest>test与autotest<a hidden class=anchor aria-hidden=true href=#test与autotest>#</a></h3><p>使用play test命令可以让程序进入测试模式，test命令和run命令其实差别不大，唯一的区别就在于使用test命令时，脚本会将play id自动替换为test，当play id为test时会自动引入testrunner模块，testrunner模块主要功能为添加@tests路由并实现了test测试页面，他的具体实现过程后续再谈。
autotest命令的作用是自动测试所有的测试用例，他的执行顺序是这样的：</p><ol><li>检查是否存在tmp文件夹，存在即删除</li><li>检查是否有程序正在运行，如存在则关闭程序</li><li>检查程序是否配置了ssl但是没有指定证书</li><li>检查是否存在test-result文件夹，存在即删除</li><li>使用test作为id重启程序</li><li>调用play.modules.testrunner.FirePhoque来进行自动化测试</li><li>关闭程序</li></ol><p>autotest的脚本的步骤1和2我觉得是有问题的，应该换下顺序，不然如果程序正在向tmp文件夹插入临时文件，那么tmp文件夹就删除失败了。
关闭程序的代码调用了<code>http://localhost:%http_port/@kill</code>进行关闭，@kill的实现方法在play.CorePlugin下，注意，@kill在prod模式下无效 (<del>这是废话</del>)<br>由于使用了python作为启动脚本，无法通过java内部变量值判断程序是否开启，只能查看控制台的输出日志，所以在使用test作为id重启后，脚本使用下面的代码判断程序是否完全启动：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>#这里启动程序</span>
</span></span><span style=display:flex><span>    play_process <span style=color:#f92672>=</span> subprocess<span style=color:#f92672>.</span>Popen(java_cmd, env<span style=color:#f92672>=</span>os<span style=color:#f92672>.</span>environ, stdout<span style=color:#f92672>=</span>sout)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>OSError</span>:
</span></span><span style=display:flex><span>        print <span style=color:#e6db74>&#34;Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). &#34;</span>
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#打开日志输出文件</span>
</span></span><span style=display:flex><span>    soutint <span style=color:#f92672>=</span> open(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(app<span style=color:#f92672>.</span>log_path(), <span style=color:#e6db74>&#39;system.out&#39;</span>), <span style=color:#e6db74>&#39;r&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> play_process<span style=color:#f92672>.</span>poll():
</span></span><span style=display:flex><span>            print <span style=color:#e6db74>&#34;~&#34;</span>
</span></span><span style=display:flex><span>            print <span style=color:#e6db74>&#34;~ Oops, application has not started?&#34;</span>
</span></span><span style=display:flex><span>            print <span style=color:#e6db74>&#34;~&#34;</span>
</span></span><span style=display:flex><span>            sys<span style=color:#f92672>.</span>exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        line <span style=color:#f92672>=</span> soutint<span style=color:#f92672>.</span>readline()<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> line:
</span></span><span style=display:flex><span>            print line
</span></span><span style=display:flex><span>            <span style=color:#75715e>#若出现&#39;Server is up and running&#39;则正常启动</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> line<span style=color:#f92672>.</span>find(<span style=color:#e6db74>&#39;Server is up and running&#39;</span>) <span style=color:#f92672>&gt;</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>: <span style=color:#75715e># This line is written out by Server.java to system.out and is not log file dependent</span>
</span></span><span style=display:flex><span>                soutint<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span></code></pre></div><p>FirePhoque类的实现过程我们之后再详解。</p><h3 id=new与clean>new与clean<a hidden class=anchor aria-hidden=true href=#new与clean>#</a></h3><p>我们使用new来创建一个新项目，play new的使用方法为<code>play new project-name [--with] [--name]</code>。
with参数为项目所使用的模块。
name为项目名，这里要注意一点，project-name和&ndash;name的参数可以设置为不同值，project-name是项目建立的文件夹名，&ndash;name的值为项目配置文件中的application.name。<br>如果不加&ndash;name，脚本会提示你是否使用project-name作为名字，在确认之后，脚本会将resources/application-skel中的所有文件拷贝到{project-name}文件夹下，然后用输入的name替换项目配置文件下的application.name，并生成一个64位的secretKey替换配置文件中的secretKey。<br>接着，脚本会查找使用的模块中是否存在dependencies.yml，并将dependencies.yml中的内容加入项目的dependencies.yml中，并调用DependenciesManager检查依赖状态。</p><p>new函数的主要代码如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print <span style=color:#e6db74>&#34;~ The new application will be created in </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>normpath(app<span style=color:#f92672>.</span>path)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> application_name <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    application_name <span style=color:#f92672>=</span> raw_input(<span style=color:#e6db74>&#34;~ What is the application name? [</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>] &#34;</span> <span style=color:#f92672>%</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(app<span style=color:#f92672>.</span>path))
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> application_name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
</span></span><span style=display:flex><span>    application_name <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(app<span style=color:#f92672>.</span>path)
</span></span><span style=display:flex><span>copy_directory(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(env[<span style=color:#e6db74>&#34;basedir&#34;</span>], <span style=color:#e6db74>&#39;resources/application-skel&#39;</span>), app<span style=color:#f92672>.</span>path)
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>mkdir(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(app<span style=color:#f92672>.</span>path, <span style=color:#e6db74>&#39;app/models&#39;</span>))
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>mkdir(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(app<span style=color:#f92672>.</span>path, <span style=color:#e6db74>&#39;lib&#39;</span>))
</span></span><span style=display:flex><span>app<span style=color:#f92672>.</span>check()
</span></span><span style=display:flex><span>replaceAll(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(app<span style=color:#f92672>.</span>path, <span style=color:#e6db74>&#39;conf/application.conf&#39;</span>), <span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;%APPLICATION_NAME%&#39;</span>, application_name)
</span></span><span style=display:flex><span>replaceAll(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(app<span style=color:#f92672>.</span>path, <span style=color:#e6db74>&#39;conf/application.conf&#39;</span>), <span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;%SECRET_KEY%&#39;</span>, secretKey())
</span></span><span style=display:flex><span>print <span style=color:#e6db74>&#34;~&#34;</span>
</span></span></code></pre></div><p>clean命令非常简单，就是删除整个tmp文件夹</p><h3 id=war与precompile>war与precompile<a hidden class=anchor aria-hidden=true href=#war与precompile>#</a></h3><p>很多时候，我们需要使用tomcat等服务器容器作为服务载体，这时候就需要将play应用打包为war<br>war的使用参数是</p><blockquote><p>play war project-name [-o/&ndash;output][filename] [&ndash;zip] [&ndash;exclude][exclude-directories]</p></blockquote><p>使用-o或&ndash;output来指定输出文件夹，使用&ndash;zip压缩为war格式，使用&ndash;exclude来包含另外需要打包的文件夹<br>要注意的是，必须在项目目录外进行操作，不然会失败</p><p>在参数处理完毕后，脚本正式开始打包过程，分为2个步骤：1.预编译。2：打包</p><p>预编译即用到了precompile命令，precompile命令与run命令几乎一样，只是在java参数中加入了<code>precompile=yes</code><br>让我们来看一下加入了这个java参数对程序的影响。
与预编译有关的代码主要是下面2段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>preCompile</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (usePrecompiled) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>getFile</span>(<span style=color:#e6db74>&#34;precompiled&#34;</span>).<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>            classloader.<span style=color:#a6e22e>getAllClasses</span>();
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Application is precompiled&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Precompiled classes are missing!!&#34;</span>);
</span></span><span style=display:flex><span>        fatalServerErrorOccurred();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//这里开始预编译</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Precompiling ...&#34;</span>);
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>setContextClassLoader</span>(Play.<span style=color:#a6e22e>classloader</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//getAllClasses方法较长，就不贴了，下面一段代码在getAllClasses方法中进入</span>
</span></span><span style=display:flex><span>        classloader.<span style=color:#a6e22e>getAllClasses</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;%sms to precompile the Java stuff&#34;</span>, System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>lazyLoadTemplates) {
</span></span><span style=display:flex><span>            start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>//编译模板</span>
</span></span><span style=display:flex><span>            TemplateLoader.<span style=color:#a6e22e>getAllTemplate</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>                Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;%sms to precompile the templates&#34;</span>, System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>error</span>(e, <span style=color:#e6db74>&#34;Cannot start in PROD mode with errors&#34;</span>);
</span></span><span style=display:flex><span>        fatalServerErrorOccurred();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>enhance</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>enhancedByteCode</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>javaByteCode</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isClass()) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// before we can start enhancing this class we must make sure it is not a PlayPlugin.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// PlayPlugins can be included as regular java files in a Play-application.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If a PlayPlugin is present in the application, it is loaded when other plugins are loaded.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// All plugins must be loaded before we can start enhancing.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This is a problem when loading PlayPlugins bundled as regular app-class since it uses the same classloader</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// as the other (soon to be) enhanched play-app-classes.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> shouldEnhance <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            CtClass ctClass <span style=color:#f92672>=</span> enhanceChecker_classPool.<span style=color:#a6e22e>makeClass</span>(<span style=color:#66d9ef>new</span> ByteArrayInputStream(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>enhancedByteCode</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (ctClass.<span style=color:#a6e22e>subclassOf</span>(ctPlayPluginClass)) {
</span></span><span style=display:flex><span>                shouldEnhance <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span>( Exception e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// nop</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (shouldEnhance) {
</span></span><span style=display:flex><span>            Play.<span style=color:#a6e22e>pluginCollection</span>.<span style=color:#a6e22e>enhance</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//主要是这一段，他将增强处理后的字节码写入了文件，增强处理在之后会深入展开</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;precompile&#34;</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// emit bytecode to standard class layout as well</span>
</span></span><span style=display:flex><span>            File f <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>getFile</span>(<span style=color:#e6db74>&#34;precompiled/java/&#34;</span> <span style=color:#f92672>+</span> (name.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34;.&#34;</span>, <span style=color:#e6db74>&#34;/&#34;</span>)) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.class&#34;</span>);
</span></span><span style=display:flex><span>            f.<span style=color:#a6e22e>getParentFile</span>().<span style=color:#a6e22e>mkdirs</span>();
</span></span><span style=display:flex><span>            FileOutputStream fos <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileOutputStream(f);
</span></span><span style=display:flex><span>            fos.<span style=color:#a6e22e>write</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>enhancedByteCode</span>);
</span></span><span style=display:flex><span>            fos.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>enhancedByteCode</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>预编译过程结束后，脚本正式开始打包过程，打包过程比较简单，就是讲预编译后的字节码文件、模板文件、配置文件、使用的类库、使用的模块类库等移动至WEB-INF文件夹中，如果使用了&ndash;zip，那么脚本会将生成的文件夹用zip格式打包。</p><h3 id=secret和status>secret和status<a hidden class=anchor aria-hidden=true href=#secret和status>#</a></h3><p>secret命令能生成一个新的secret key
status命令是用于实时显示程序的运行状态，脚本的运作十分简单，步骤如下：</p><ol><li>检查是否有&ndash;url参数，有则在他之后添加@status</li><li>检查是否存在&ndash;secret</li><li>如果没有&ndash;url，则使用<code>http://localhost:%http_port/@status</code>;如果没有 &ndash;secret，则从配置文件中读取secret key</li><li>将secret_key、&rsquo;@status&rsquo;使用sha加密，并加入Authorization请求头</li><li>发送请求</li></ol><p>@status的实现和@kill一样在CorePlugin类中，这在之后再进行详解。</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>Play的启动脚本分析至此就结束了，从脚本的分析过程中我们可以稍微探究下Play在脚本启动阶段有何行为，这对我们进行脚本改造或者启动优化还是非常有帮助的。
下一篇，我们来看看Play的启动类是如何运作的。。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://example.org/tags/program/>Program</a></li><li><a href=https://example.org/tags/backend/>Backend</a></li></ul><nav class=paginav><a class=prev href=https://example.org/posts/play-framework/part2server%E4%B8%8Eservletwrapper/><span class=title>« Prev</span><br><span>Play framework源码解析 Part2:Server与ServletWrapper</span>
</a><a class=next href=https://example.org/posts/play-framework/play-framework%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%9B%AE%E5%BD%95/><span class=title>Next »</span><br><span>Play framework源码解析目录</span></a></nav></footer><script src=https://utteranc.es/client.js repo=asukaonly/asukaonly.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://example.org/>404 NOT FOUND</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>