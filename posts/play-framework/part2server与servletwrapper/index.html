<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Play framework源码解析 Part2:Server与ServletWrapper | 404 NOT FOUND</title><meta name=keywords content="program,backend"><meta name=description content='在上一节中我们剖析了Play framework的启动原理，很容易就能发现Play framework的启动主入口在play.server.Server中，在本节，我们来一起看看Server类中主要发生了什么。
Server类
既然是程序运行的主入口，那么必然是由main方法进入的，Server类中的main方法十分简单。源码如下:

public static void main(String[] args) throws Exception {
    File root = new File(System.getProperty("application.path"));
    //获取参数中的precompiled
    if (System.getProperty("precompiled", "false").equals("true")) {
        Play.usePrecompiled = true;
    }
    //获取参数中的writepid
    if (System.getProperty("writepid", "false").equals("true")) {
        //这个方法的作用是检查当前目录下是否存在server.pid文件，若存在表明当前已有程序在运行
        writePID(root);
    }
    //Play类的初始化
    Play.init(root, System.getProperty("play.id", ""));
    if (System.getProperty("precompile") == null) {
        //Server类初始化
        new Server(args);
    } else {
        Logger.info("Done.");
    }
}
main方法执行的操作很简单:

获取程序路径
检查是否存在precompiled参数
检查是否存在writepid参数，若存在则检查是否存在server.pid文件，若存在则表明已有程序在运行，不存在则将当前程序pid写入server.pid
play类初始化
检查是否存在precompile参数项，若存在表示是个预编译行为，结束运行，若没有则启动服务

这其中最重要的便是Play类的初始化以及Server类的初始化
这里我们先来看Server类的初始化过程，现在可以先简单的将Play类的初始化理解为Play框架中一些常量的初始化以及日志、配置文件、路由信息等配置的读取。
这里贴一下Server类的初始化过程：
public Server(String[] args) {
    //设置文件编码为UTF-8
    System.setProperty("file.encoding", "utf-8");
    //p为Play类初始化过程中读取的配置文件信息
    final Properties p = Play.configuration;
    //获取参数中的http与https端口信息，若不存在则用配置文件中的http与https端口信息
    httpPort = Integer.parseInt(getOpt(args, "http.port", p.getProperty("http.port", "-1")));
    httpsPort = Integer.parseInt(getOpt(args, "https.port", p.getProperty("https.port", "-1")));
    //若没有配置则设置默认端口为9000
    if (httpPort == -1 && httpsPort == -1) {
        httpPort = 9000;
    }
    //http与https端口不能相同
    if (httpPort == httpsPort) {
        Logger.error("Could not bind on https and http on the same port " + httpPort);
        Play.fatalServerErrorOccurred();
    }

    InetAddress address = null;
    InetAddress secureAddress = null;
    try {
        //获取配置文件中的默认http地址，若不存在则在系统参数中查找
        //之前还是参数配置大于配置文件，这里不知道为什么又变成了配置文件的优先级高于参数配置，很迷
        if (p.getProperty("http.address") != null) {
            address = InetAddress.getByName(p.getProperty("http.address"));
        } else if (System.getProperties().containsKey("http.address")) {
            address = InetAddress.getByName(System.getProperty("http.address"));
        }

    } catch (Exception e) {
        Logger.error(e, "Could not understand http.address");
        Play.fatalServerErrorOccurred();
    }
    try {
        //同上，获取https地址
        if (p.getProperty("https.address") != null) {
            secureAddress = InetAddress.getByName(p.getProperty("https.address"));
        } else if (System.getProperties().containsKey("https.address")) {
            secureAddress = InetAddress.getByName(System.getProperty("https.address"));
        }
    } catch (Exception e) {
        Logger.error(e, "Could not understand https.address");
        Play.fatalServerErrorOccurred();
    }
    //netty服务器启动类初始化，使用nio服务器，无限制线程池
    //这里的线程池是netty的主线程池与工作线程池，是处理连接的线程池，而Play实际执行业务操作的线程池在另一个地方配置
    ServerBootstrap bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(
            Executors.newCachedThreadPool(), Executors.newCachedThreadPool())
    );
    try {
        //初始化http端口
        if (httpPort != -1) {
            //设置管道工厂类
            bootstrap.setPipelineFactory(new HttpServerPipelineFactory());
            //绑定端口
            bootstrap.bind(new InetSocketAddress(address, httpPort));
            bootstrap.setOption("child.tcpNoDelay", true);

            if (Play.mode == Mode.DEV) {
                if (address == null) {
                    Logger.info("Listening for HTTP on port %s (Waiting a first request to start) ...", httpPort);
                } else {
                    Logger.info("Listening for HTTP at %2$s:%1$s (Waiting a first request to start) ...", httpPort, address);
                }
            } else {
                if (address == null) {
                    Logger.info("Listening for HTTP on port %s ...", httpPort);
                } else {
                    Logger.info("Listening for HTTP at %2$s:%1$s  ...", httpPort, address);
                }
            }

        }

    } catch (ChannelException e) {
        Logger.error("Could not bind on port " + httpPort, e);
        Play.fatalServerErrorOccurred();
    }
    //下面是https端口服务器的启动过程，和http一致
    bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(
            Executors.newCachedThreadPool(), Executors.newCachedThreadPool())
    );

    try {
        if (httpsPort != -1) {
            //这里的管道工厂类变成了SslHttpServerPipelineFactory
            bootstrap.setPipelineFactory(new SslHttpServerPipelineFactory());
            bootstrap.bind(new InetSocketAddress(secureAddress, httpsPort));
            bootstrap.setOption("child.tcpNoDelay", true);

            if (Play.mode == Mode.DEV) {
                if (secureAddress == null) {
                    Logger.info("Listening for HTTPS on port %s (Waiting a first request to start) ...", httpsPort);
                } else {
                    Logger.info("Listening for HTTPS at %2$s:%1$s (Waiting a first request to start) ...", httpsPort, secureAddress);
                }
            } else {
                if (secureAddress == null) {
                    Logger.info("Listening for HTTPS on port %s ...", httpsPort);
                } else {
                    Logger.info("Listening for HTTPS at %2$s:%1$s  ...", httpsPort, secureAddress);
                }
            }

        }

    } catch (ChannelException e) {
        Logger.error("Could not bind on port " + httpsPort, e);
        Play.fatalServerErrorOccurred();
    }
    if (Play.mode == Mode.DEV) {
        // print this line to STDOUT - not using logger, so auto test runner will not block if logger is misconfigured (see #1222)
        //输出启动成功，以便进行自动化测试
        System.out.println("~ Server is up and running");
    }
}
server类的初始化没什么好说的，重点就在于那2个管道工厂类，HttpServerPipelineFactory与SslHttpServerPipelineFactory'><meta name=author content="luyanliang"><link rel=canonical href=https://example.org/posts/play-framework/part2server%E4%B8%8Eservletwrapper/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b5d6aea30d7e14de4dcda80e3d0ee4ec39cfe328c153798afa1f394ef198a41a.css integrity="sha256-tdauow1+FN5NzagOPQ7k7DnP4yjBU3mK+h85TvGYpBo=" rel="preload stylesheet" as=style><link rel=icon href=https://example.org/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://example.org/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://example.org/avatar.png><link rel=apple-touch-icon href=https://example.org/avatar.png><link rel=mask-icon href=https://example.org/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://example.org/posts/play-framework/part2server%E4%B8%8Eservletwrapper/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://example.org/posts/play-framework/part2server%E4%B8%8Eservletwrapper/"><meta property="og:site_name" content="404 NOT FOUND"><meta property="og:title" content="Play framework源码解析 Part2:Server与ServletWrapper"><meta property="og:description" content='在上一节中我们剖析了Play framework的启动原理，很容易就能发现Play framework的启动主入口在play.server.Server中，在本节，我们来一起看看Server类中主要发生了什么。
Server类 既然是程序运行的主入口，那么必然是由main方法进入的，Server类中的main方法十分简单。源码如下:
public static void main(String[] args) throws Exception { File root = new File(System.getProperty("application.path")); //获取参数中的precompiled if (System.getProperty("precompiled", "false").equals("true")) { Play.usePrecompiled = true; } //获取参数中的writepid if (System.getProperty("writepid", "false").equals("true")) { //这个方法的作用是检查当前目录下是否存在server.pid文件，若存在表明当前已有程序在运行 writePID(root); } //Play类的初始化 Play.init(root, System.getProperty("play.id", "")); if (System.getProperty("precompile") == null) { //Server类初始化 new Server(args); } else { Logger.info("Done."); } } main方法执行的操作很简单:
获取程序路径 检查是否存在precompiled参数 检查是否存在writepid参数，若存在则检查是否存在server.pid文件，若存在则表明已有程序在运行，不存在则将当前程序pid写入server.pid play类初始化 检查是否存在precompile参数项，若存在表示是个预编译行为，结束运行，若没有则启动服务 这其中最重要的便是Play类的初始化以及Server类的初始化 这里我们先来看Server类的初始化过程，现在可以先简单的将Play类的初始化理解为Play框架中一些常量的初始化以及日志、配置文件、路由信息等配置的读取。 这里贴一下Server类的初始化过程：
public Server(String[] args) { //设置文件编码为UTF-8 System.setProperty("file.encoding", "utf-8"); //p为Play类初始化过程中读取的配置文件信息 final Properties p = Play.configuration; //获取参数中的http与https端口信息，若不存在则用配置文件中的http与https端口信息 httpPort = Integer.parseInt(getOpt(args, "http.port", p.getProperty("http.port", "-1"))); httpsPort = Integer.parseInt(getOpt(args, "https.port", p.getProperty("https.port", "-1"))); //若没有配置则设置默认端口为9000 if (httpPort == -1 && httpsPort == -1) { httpPort = 9000; } //http与https端口不能相同 if (httpPort == httpsPort) { Logger.error("Could not bind on https and http on the same port " + httpPort); Play.fatalServerErrorOccurred(); } InetAddress address = null; InetAddress secureAddress = null; try { //获取配置文件中的默认http地址，若不存在则在系统参数中查找 //之前还是参数配置大于配置文件，这里不知道为什么又变成了配置文件的优先级高于参数配置，很迷 if (p.getProperty("http.address") != null) { address = InetAddress.getByName(p.getProperty("http.address")); } else if (System.getProperties().containsKey("http.address")) { address = InetAddress.getByName(System.getProperty("http.address")); } } catch (Exception e) { Logger.error(e, "Could not understand http.address"); Play.fatalServerErrorOccurred(); } try { //同上，获取https地址 if (p.getProperty("https.address") != null) { secureAddress = InetAddress.getByName(p.getProperty("https.address")); } else if (System.getProperties().containsKey("https.address")) { secureAddress = InetAddress.getByName(System.getProperty("https.address")); } } catch (Exception e) { Logger.error(e, "Could not understand https.address"); Play.fatalServerErrorOccurred(); } //netty服务器启动类初始化，使用nio服务器，无限制线程池 //这里的线程池是netty的主线程池与工作线程池，是处理连接的线程池，而Play实际执行业务操作的线程池在另一个地方配置 ServerBootstrap bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory( Executors.newCachedThreadPool(), Executors.newCachedThreadPool()) ); try { //初始化http端口 if (httpPort != -1) { //设置管道工厂类 bootstrap.setPipelineFactory(new HttpServerPipelineFactory()); //绑定端口 bootstrap.bind(new InetSocketAddress(address, httpPort)); bootstrap.setOption("child.tcpNoDelay", true); if (Play.mode == Mode.DEV) { if (address == null) { Logger.info("Listening for HTTP on port %s (Waiting a first request to start) ...", httpPort); } else { Logger.info("Listening for HTTP at %2$s:%1$s (Waiting a first request to start) ...", httpPort, address); } } else { if (address == null) { Logger.info("Listening for HTTP on port %s ...", httpPort); } else { Logger.info("Listening for HTTP at %2$s:%1$s ...", httpPort, address); } } } } catch (ChannelException e) { Logger.error("Could not bind on port " + httpPort, e); Play.fatalServerErrorOccurred(); } //下面是https端口服务器的启动过程，和http一致 bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory( Executors.newCachedThreadPool(), Executors.newCachedThreadPool()) ); try { if (httpsPort != -1) { //这里的管道工厂类变成了SslHttpServerPipelineFactory bootstrap.setPipelineFactory(new SslHttpServerPipelineFactory()); bootstrap.bind(new InetSocketAddress(secureAddress, httpsPort)); bootstrap.setOption("child.tcpNoDelay", true); if (Play.mode == Mode.DEV) { if (secureAddress == null) { Logger.info("Listening for HTTPS on port %s (Waiting a first request to start) ...", httpsPort); } else { Logger.info("Listening for HTTPS at %2$s:%1$s (Waiting a first request to start) ...", httpsPort, secureAddress); } } else { if (secureAddress == null) { Logger.info("Listening for HTTPS on port %s ...", httpsPort); } else { Logger.info("Listening for HTTPS at %2$s:%1$s ...", httpsPort, secureAddress); } } } } catch (ChannelException e) { Logger.error("Could not bind on port " + httpsPort, e); Play.fatalServerErrorOccurred(); } if (Play.mode == Mode.DEV) { // print this line to STDOUT - not using logger, so auto test runner will not block if logger is misconfigured (see #1222) //输出启动成功，以便进行自动化测试 System.out.println("~ Server is up and running"); } } server类的初始化没什么好说的，重点就在于那2个管道工厂类，HttpServerPipelineFactory与SslHttpServerPipelineFactory'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-11T15:16:54+00:00"><meta property="article:modified_time" content="2018-01-11T15:16:54+00:00"><meta property="article:tag" content="Program"><meta property="article:tag" content="Backend"><meta property="og:image" content="https://example.org/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://example.org/avatar.png"><meta name=twitter:title content="Play framework源码解析 Part2:Server与ServletWrapper"><meta name=twitter:description content='在上一节中我们剖析了Play framework的启动原理，很容易就能发现Play framework的启动主入口在play.server.Server中，在本节，我们来一起看看Server类中主要发生了什么。
Server类
既然是程序运行的主入口，那么必然是由main方法进入的，Server类中的main方法十分简单。源码如下:

public static void main(String[] args) throws Exception {
    File root = new File(System.getProperty("application.path"));
    //获取参数中的precompiled
    if (System.getProperty("precompiled", "false").equals("true")) {
        Play.usePrecompiled = true;
    }
    //获取参数中的writepid
    if (System.getProperty("writepid", "false").equals("true")) {
        //这个方法的作用是检查当前目录下是否存在server.pid文件，若存在表明当前已有程序在运行
        writePID(root);
    }
    //Play类的初始化
    Play.init(root, System.getProperty("play.id", ""));
    if (System.getProperty("precompile") == null) {
        //Server类初始化
        new Server(args);
    } else {
        Logger.info("Done.");
    }
}
main方法执行的操作很简单:

获取程序路径
检查是否存在precompiled参数
检查是否存在writepid参数，若存在则检查是否存在server.pid文件，若存在则表明已有程序在运行，不存在则将当前程序pid写入server.pid
play类初始化
检查是否存在precompile参数项，若存在表示是个预编译行为，结束运行，若没有则启动服务

这其中最重要的便是Play类的初始化以及Server类的初始化
这里我们先来看Server类的初始化过程，现在可以先简单的将Play类的初始化理解为Play框架中一些常量的初始化以及日志、配置文件、路由信息等配置的读取。
这里贴一下Server类的初始化过程：
public Server(String[] args) {
    //设置文件编码为UTF-8
    System.setProperty("file.encoding", "utf-8");
    //p为Play类初始化过程中读取的配置文件信息
    final Properties p = Play.configuration;
    //获取参数中的http与https端口信息，若不存在则用配置文件中的http与https端口信息
    httpPort = Integer.parseInt(getOpt(args, "http.port", p.getProperty("http.port", "-1")));
    httpsPort = Integer.parseInt(getOpt(args, "https.port", p.getProperty("https.port", "-1")));
    //若没有配置则设置默认端口为9000
    if (httpPort == -1 && httpsPort == -1) {
        httpPort = 9000;
    }
    //http与https端口不能相同
    if (httpPort == httpsPort) {
        Logger.error("Could not bind on https and http on the same port " + httpPort);
        Play.fatalServerErrorOccurred();
    }

    InetAddress address = null;
    InetAddress secureAddress = null;
    try {
        //获取配置文件中的默认http地址，若不存在则在系统参数中查找
        //之前还是参数配置大于配置文件，这里不知道为什么又变成了配置文件的优先级高于参数配置，很迷
        if (p.getProperty("http.address") != null) {
            address = InetAddress.getByName(p.getProperty("http.address"));
        } else if (System.getProperties().containsKey("http.address")) {
            address = InetAddress.getByName(System.getProperty("http.address"));
        }

    } catch (Exception e) {
        Logger.error(e, "Could not understand http.address");
        Play.fatalServerErrorOccurred();
    }
    try {
        //同上，获取https地址
        if (p.getProperty("https.address") != null) {
            secureAddress = InetAddress.getByName(p.getProperty("https.address"));
        } else if (System.getProperties().containsKey("https.address")) {
            secureAddress = InetAddress.getByName(System.getProperty("https.address"));
        }
    } catch (Exception e) {
        Logger.error(e, "Could not understand https.address");
        Play.fatalServerErrorOccurred();
    }
    //netty服务器启动类初始化，使用nio服务器，无限制线程池
    //这里的线程池是netty的主线程池与工作线程池，是处理连接的线程池，而Play实际执行业务操作的线程池在另一个地方配置
    ServerBootstrap bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(
            Executors.newCachedThreadPool(), Executors.newCachedThreadPool())
    );
    try {
        //初始化http端口
        if (httpPort != -1) {
            //设置管道工厂类
            bootstrap.setPipelineFactory(new HttpServerPipelineFactory());
            //绑定端口
            bootstrap.bind(new InetSocketAddress(address, httpPort));
            bootstrap.setOption("child.tcpNoDelay", true);

            if (Play.mode == Mode.DEV) {
                if (address == null) {
                    Logger.info("Listening for HTTP on port %s (Waiting a first request to start) ...", httpPort);
                } else {
                    Logger.info("Listening for HTTP at %2$s:%1$s (Waiting a first request to start) ...", httpPort, address);
                }
            } else {
                if (address == null) {
                    Logger.info("Listening for HTTP on port %s ...", httpPort);
                } else {
                    Logger.info("Listening for HTTP at %2$s:%1$s  ...", httpPort, address);
                }
            }

        }

    } catch (ChannelException e) {
        Logger.error("Could not bind on port " + httpPort, e);
        Play.fatalServerErrorOccurred();
    }
    //下面是https端口服务器的启动过程，和http一致
    bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(
            Executors.newCachedThreadPool(), Executors.newCachedThreadPool())
    );

    try {
        if (httpsPort != -1) {
            //这里的管道工厂类变成了SslHttpServerPipelineFactory
            bootstrap.setPipelineFactory(new SslHttpServerPipelineFactory());
            bootstrap.bind(new InetSocketAddress(secureAddress, httpsPort));
            bootstrap.setOption("child.tcpNoDelay", true);

            if (Play.mode == Mode.DEV) {
                if (secureAddress == null) {
                    Logger.info("Listening for HTTPS on port %s (Waiting a first request to start) ...", httpsPort);
                } else {
                    Logger.info("Listening for HTTPS at %2$s:%1$s (Waiting a first request to start) ...", httpsPort, secureAddress);
                }
            } else {
                if (secureAddress == null) {
                    Logger.info("Listening for HTTPS on port %s ...", httpsPort);
                } else {
                    Logger.info("Listening for HTTPS at %2$s:%1$s  ...", httpsPort, secureAddress);
                }
            }

        }

    } catch (ChannelException e) {
        Logger.error("Could not bind on port " + httpsPort, e);
        Play.fatalServerErrorOccurred();
    }
    if (Play.mode == Mode.DEV) {
        // print this line to STDOUT - not using logger, so auto test runner will not block if logger is misconfigured (see #1222)
        //输出启动成功，以便进行自动化测试
        System.out.println("~ Server is up and running");
    }
}
server类的初始化没什么好说的，重点就在于那2个管道工厂类，HttpServerPipelineFactory与SslHttpServerPipelineFactory'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://example.org/posts/"},{"@type":"ListItem","position":2,"name":"Play framework源码解析 Part2:Server与ServletWrapper","item":"https://example.org/posts/play-framework/part2server%E4%B8%8Eservletwrapper/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Play framework源码解析 Part2:Server与ServletWrapper","name":"Play framework源码解析 Part2:Server与ServletWrapper","description":"在上一节中我们剖析了Play framework的启动原理，很容易就能发现Play framework的启动主入口在play.server.Server中，在本节，我们来一起看看Server类中主要发生了什么。\nServer类 既然是程序运行的主入口，那么必然是由main方法进入的，Server类中的main方法十分简单。源码如下:\npublic static void main(String[] args) throws Exception { File root = new File(System.getProperty(\u0026#34;application.path\u0026#34;)); //获取参数中的precompiled if (System.getProperty(\u0026#34;precompiled\u0026#34;, \u0026#34;false\u0026#34;).equals(\u0026#34;true\u0026#34;)) { Play.usePrecompiled = true; } //获取参数中的writepid if (System.getProperty(\u0026#34;writepid\u0026#34;, \u0026#34;false\u0026#34;).equals(\u0026#34;true\u0026#34;)) { //这个方法的作用是检查当前目录下是否存在server.pid文件，若存在表明当前已有程序在运行 writePID(root); } //Play类的初始化 Play.init(root, System.getProperty(\u0026#34;play.id\u0026#34;, \u0026#34;\u0026#34;)); if (System.getProperty(\u0026#34;precompile\u0026#34;) == null) { //Server类初始化 new Server(args); } else { Logger.info(\u0026#34;Done.\u0026#34;); } } main方法执行的操作很简单:\n获取程序路径 检查是否存在precompiled参数 检查是否存在writepid参数，若存在则检查是否存在server.pid文件，若存在则表明已有程序在运行，不存在则将当前程序pid写入server.pid play类初始化 检查是否存在precompile参数项，若存在表示是个预编译行为，结束运行，若没有则启动服务 这其中最重要的便是Play类的初始化以及Server类的初始化 这里我们先来看Server类的初始化过程，现在可以先简单的将Play类的初始化理解为Play框架中一些常量的初始化以及日志、配置文件、路由信息等配置的读取。 这里贴一下Server类的初始化过程：\npublic Server(String[] args) { //设置文件编码为UTF-8 System.setProperty(\u0026#34;file.encoding\u0026#34;, \u0026#34;utf-8\u0026#34;); //p为Play类初始化过程中读取的配置文件信息 final Properties p = Play.configuration; //获取参数中的http与https端口信息，若不存在则用配置文件中的http与https端口信息 httpPort = Integer.parseInt(getOpt(args, \u0026#34;http.port\u0026#34;, p.getProperty(\u0026#34;http.port\u0026#34;, \u0026#34;-1\u0026#34;))); httpsPort = Integer.parseInt(getOpt(args, \u0026#34;https.port\u0026#34;, p.getProperty(\u0026#34;https.port\u0026#34;, \u0026#34;-1\u0026#34;))); //若没有配置则设置默认端口为9000 if (httpPort == -1 \u0026amp;\u0026amp; httpsPort == -1) { httpPort = 9000; } //http与https端口不能相同 if (httpPort == httpsPort) { Logger.error(\u0026#34;Could not bind on https and http on the same port \u0026#34; + httpPort); Play.fatalServerErrorOccurred(); } InetAddress address = null; InetAddress secureAddress = null; try { //获取配置文件中的默认http地址，若不存在则在系统参数中查找 //之前还是参数配置大于配置文件，这里不知道为什么又变成了配置文件的优先级高于参数配置，很迷 if (p.getProperty(\u0026#34;http.address\u0026#34;) != null) { address = InetAddress.getByName(p.getProperty(\u0026#34;http.address\u0026#34;)); } else if (System.getProperties().containsKey(\u0026#34;http.address\u0026#34;)) { address = InetAddress.getByName(System.getProperty(\u0026#34;http.address\u0026#34;)); } } catch (Exception e) { Logger.error(e, \u0026#34;Could not understand http.address\u0026#34;); Play.fatalServerErrorOccurred(); } try { //同上，获取https地址 if (p.getProperty(\u0026#34;https.address\u0026#34;) != null) { secureAddress = InetAddress.getByName(p.getProperty(\u0026#34;https.address\u0026#34;)); } else if (System.getProperties().containsKey(\u0026#34;https.address\u0026#34;)) { secureAddress = InetAddress.getByName(System.getProperty(\u0026#34;https.address\u0026#34;)); } } catch (Exception e) { Logger.error(e, \u0026#34;Could not understand https.address\u0026#34;); Play.fatalServerErrorOccurred(); } //netty服务器启动类初始化，使用nio服务器，无限制线程池 //这里的线程池是netty的主线程池与工作线程池，是处理连接的线程池，而Play实际执行业务操作的线程池在另一个地方配置 ServerBootstrap bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory( Executors.newCachedThreadPool(), Executors.newCachedThreadPool()) ); try { //初始化http端口 if (httpPort != -1) { //设置管道工厂类 bootstrap.setPipelineFactory(new HttpServerPipelineFactory()); //绑定端口 bootstrap.bind(new InetSocketAddress(address, httpPort)); bootstrap.setOption(\u0026#34;child.tcpNoDelay\u0026#34;, true); if (Play.mode == Mode.DEV) { if (address == null) { Logger.info(\u0026#34;Listening for HTTP on port %s (Waiting a first request to start) ...\u0026#34;, httpPort); } else { Logger.info(\u0026#34;Listening for HTTP at %2$s:%1$s (Waiting a first request to start) ...\u0026#34;, httpPort, address); } } else { if (address == null) { Logger.info(\u0026#34;Listening for HTTP on port %s ...\u0026#34;, httpPort); } else { Logger.info(\u0026#34;Listening for HTTP at %2$s:%1$s ...\u0026#34;, httpPort, address); } } } } catch (ChannelException e) { Logger.error(\u0026#34;Could not bind on port \u0026#34; + httpPort, e); Play.fatalServerErrorOccurred(); } //下面是https端口服务器的启动过程，和http一致 bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory( Executors.newCachedThreadPool(), Executors.newCachedThreadPool()) ); try { if (httpsPort != -1) { //这里的管道工厂类变成了SslHttpServerPipelineFactory bootstrap.setPipelineFactory(new SslHttpServerPipelineFactory()); bootstrap.bind(new InetSocketAddress(secureAddress, httpsPort)); bootstrap.setOption(\u0026#34;child.tcpNoDelay\u0026#34;, true); if (Play.mode == Mode.DEV) { if (secureAddress == null) { Logger.info(\u0026#34;Listening for HTTPS on port %s (Waiting a first request to start) ...\u0026#34;, httpsPort); } else { Logger.info(\u0026#34;Listening for HTTPS at %2$s:%1$s (Waiting a first request to start) ...\u0026#34;, httpsPort, secureAddress); } } else { if (secureAddress == null) { Logger.info(\u0026#34;Listening for HTTPS on port %s ...\u0026#34;, httpsPort); } else { Logger.info(\u0026#34;Listening for HTTPS at %2$s:%1$s ...\u0026#34;, httpsPort, secureAddress); } } } } catch (ChannelException e) { Logger.error(\u0026#34;Could not bind on port \u0026#34; + httpsPort, e); Play.fatalServerErrorOccurred(); } if (Play.mode == Mode.DEV) { // print this line to STDOUT - not using logger, so auto test runner will not block if logger is misconfigured (see #1222) //输出启动成功，以便进行自动化测试 System.out.println(\u0026#34;~ Server is up and running\u0026#34;); } } server类的初始化没什么好说的，重点就在于那2个管道工厂类，HttpServerPipelineFactory与SslHttpServerPipelineFactory\n","keywords":["program","backend"],"articleBody":"在上一节中我们剖析了Play framework的启动原理，很容易就能发现Play framework的启动主入口在play.server.Server中，在本节，我们来一起看看Server类中主要发生了什么。\nServer类 既然是程序运行的主入口，那么必然是由main方法进入的，Server类中的main方法十分简单。源码如下:\npublic static void main(String[] args) throws Exception { File root = new File(System.getProperty(\"application.path\")); //获取参数中的precompiled if (System.getProperty(\"precompiled\", \"false\").equals(\"true\")) { Play.usePrecompiled = true; } //获取参数中的writepid if (System.getProperty(\"writepid\", \"false\").equals(\"true\")) { //这个方法的作用是检查当前目录下是否存在server.pid文件，若存在表明当前已有程序在运行 writePID(root); } //Play类的初始化 Play.init(root, System.getProperty(\"play.id\", \"\")); if (System.getProperty(\"precompile\") == null) { //Server类初始化 new Server(args); } else { Logger.info(\"Done.\"); } } main方法执行的操作很简单:\n获取程序路径 检查是否存在precompiled参数 检查是否存在writepid参数，若存在则检查是否存在server.pid文件，若存在则表明已有程序在运行，不存在则将当前程序pid写入server.pid play类初始化 检查是否存在precompile参数项，若存在表示是个预编译行为，结束运行，若没有则启动服务 这其中最重要的便是Play类的初始化以及Server类的初始化 这里我们先来看Server类的初始化过程，现在可以先简单的将Play类的初始化理解为Play框架中一些常量的初始化以及日志、配置文件、路由信息等配置的读取。 这里贴一下Server类的初始化过程：\npublic Server(String[] args) { //设置文件编码为UTF-8 System.setProperty(\"file.encoding\", \"utf-8\"); //p为Play类初始化过程中读取的配置文件信息 final Properties p = Play.configuration; //获取参数中的http与https端口信息，若不存在则用配置文件中的http与https端口信息 httpPort = Integer.parseInt(getOpt(args, \"http.port\", p.getProperty(\"http.port\", \"-1\"))); httpsPort = Integer.parseInt(getOpt(args, \"https.port\", p.getProperty(\"https.port\", \"-1\"))); //若没有配置则设置默认端口为9000 if (httpPort == -1 \u0026\u0026 httpsPort == -1) { httpPort = 9000; } //http与https端口不能相同 if (httpPort == httpsPort) { Logger.error(\"Could not bind on https and http on the same port \" + httpPort); Play.fatalServerErrorOccurred(); } InetAddress address = null; InetAddress secureAddress = null; try { //获取配置文件中的默认http地址，若不存在则在系统参数中查找 //之前还是参数配置大于配置文件，这里不知道为什么又变成了配置文件的优先级高于参数配置，很迷 if (p.getProperty(\"http.address\") != null) { address = InetAddress.getByName(p.getProperty(\"http.address\")); } else if (System.getProperties().containsKey(\"http.address\")) { address = InetAddress.getByName(System.getProperty(\"http.address\")); } } catch (Exception e) { Logger.error(e, \"Could not understand http.address\"); Play.fatalServerErrorOccurred(); } try { //同上，获取https地址 if (p.getProperty(\"https.address\") != null) { secureAddress = InetAddress.getByName(p.getProperty(\"https.address\")); } else if (System.getProperties().containsKey(\"https.address\")) { secureAddress = InetAddress.getByName(System.getProperty(\"https.address\")); } } catch (Exception e) { Logger.error(e, \"Could not understand https.address\"); Play.fatalServerErrorOccurred(); } //netty服务器启动类初始化，使用nio服务器，无限制线程池 //这里的线程池是netty的主线程池与工作线程池，是处理连接的线程池，而Play实际执行业务操作的线程池在另一个地方配置 ServerBootstrap bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory( Executors.newCachedThreadPool(), Executors.newCachedThreadPool()) ); try { //初始化http端口 if (httpPort != -1) { //设置管道工厂类 bootstrap.setPipelineFactory(new HttpServerPipelineFactory()); //绑定端口 bootstrap.bind(new InetSocketAddress(address, httpPort)); bootstrap.setOption(\"child.tcpNoDelay\", true); if (Play.mode == Mode.DEV) { if (address == null) { Logger.info(\"Listening for HTTP on port %s (Waiting a first request to start) ...\", httpPort); } else { Logger.info(\"Listening for HTTP at %2$s:%1$s (Waiting a first request to start) ...\", httpPort, address); } } else { if (address == null) { Logger.info(\"Listening for HTTP on port %s ...\", httpPort); } else { Logger.info(\"Listening for HTTP at %2$s:%1$s ...\", httpPort, address); } } } } catch (ChannelException e) { Logger.error(\"Could not bind on port \" + httpPort, e); Play.fatalServerErrorOccurred(); } //下面是https端口服务器的启动过程，和http一致 bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory( Executors.newCachedThreadPool(), Executors.newCachedThreadPool()) ); try { if (httpsPort != -1) { //这里的管道工厂类变成了SslHttpServerPipelineFactory bootstrap.setPipelineFactory(new SslHttpServerPipelineFactory()); bootstrap.bind(new InetSocketAddress(secureAddress, httpsPort)); bootstrap.setOption(\"child.tcpNoDelay\", true); if (Play.mode == Mode.DEV) { if (secureAddress == null) { Logger.info(\"Listening for HTTPS on port %s (Waiting a first request to start) ...\", httpsPort); } else { Logger.info(\"Listening for HTTPS at %2$s:%1$s (Waiting a first request to start) ...\", httpsPort, secureAddress); } } else { if (secureAddress == null) { Logger.info(\"Listening for HTTPS on port %s ...\", httpsPort); } else { Logger.info(\"Listening for HTTPS at %2$s:%1$s ...\", httpsPort, secureAddress); } } } } catch (ChannelException e) { Logger.error(\"Could not bind on port \" + httpsPort, e); Play.fatalServerErrorOccurred(); } if (Play.mode == Mode.DEV) { // print this line to STDOUT - not using logger, so auto test runner will not block if logger is misconfigured (see #1222) //输出启动成功，以便进行自动化测试 System.out.println(\"~ Server is up and running\"); } } server类的初始化没什么好说的，重点就在于那2个管道工厂类，HttpServerPipelineFactory与SslHttpServerPipelineFactory\nHttpServerPipelineFactory HttpServerPipelineFactory类作用就是为netty服务器增加了各个ChannelHandler。\npublic class HttpServerPipelineFactory implements ChannelPipelineFactory { public ChannelPipeline getPipeline() throws Exception { Integer max = Integer.valueOf(Play.configuration.getProperty(\"play.netty.maxContentLength\", \"-1\")); ChannelPipeline pipeline = pipeline(); PlayHandler playHandler = new PlayHandler(); pipeline.addLast(\"flashPolicy\", new FlashPolicyHandler()); pipeline.addLast(\"decoder\", new HttpRequestDecoder()); pipeline.addLast(\"aggregator\", new StreamChunkAggregator(max)); pipeline.addLast(\"encoder\", new HttpResponseEncoder()); pipeline.addLast(\"chunkedWriter\", playHandler.chunkedWriteHandler); pipeline.addLast(\"handler\", playHandler); return pipeline; } } pipeline依次添加了flash处理器，http request解码器，流区块聚合器，http response编码器，区块写入器，play处理器\nflash处理器和流区块聚合器这里暂且不作详细解析，读者可以理解为这2者的作用分别为传输flash流和合并请求头中有Transfer-Encoding:chunked的请求数据。\nPlayHandler类是Play将netty接收到的request转换为play的request并真正开始业务处理的入口类，我们先暂时放下PlayHandler，先来看看SslHttpServerPipelineFactory做了什么\nSslHttpServerPipelineFactory SslHttpServerPipelineFactory是https使用的管道工厂类，他除了添加了一下处理器外，最重要的是根据配置创建了https的连接方式。\npublic ChannelPipeline getPipeline() throws Exception { Integer max = Integer.valueOf(Play.configuration.getProperty(\"play.netty.maxContentLength\", \"-1\")); String mode = Play.configuration.getProperty(\"play.netty.clientAuth\", \"none\"); ChannelPipeline pipeline = pipeline(); // Add SSL handler first to encrypt and decrypt everything. SSLEngine engine = SslHttpServerContextFactory.getServerContext().createSSLEngine(); engine.setUseClientMode(false); if (\"want\".equalsIgnoreCase(mode)) { engine.setWantClientAuth(true); } else if (\"need\".equalsIgnoreCase(mode)) { engine.setNeedClientAuth(true); } engine.setEnableSessionCreation(true); pipeline.addLast(\"flashPolicy\", new FlashPolicyHandler()); pipeline.addLast(\"ssl\", new SslHandler(engine)); pipeline.addLast(\"decoder\", new HttpRequestDecoder()); pipeline.addLast(\"aggregator\", new StreamChunkAggregator(max)); pipeline.addLast(\"encoder\", new HttpResponseEncoder()); pipeline.addLast(\"chunkedWriter\", new ChunkedWriteHandler()); pipeline.addLast(\"handler\", new SslPlayHandler()); return pipeline; } 在设置完SSLEngine后，SslHttpServerPipelineFactory在decoder处理器前加了一个SslHandler来处理连接，这里不是使用playHandler作为处理器，而是使用SslPlayHandler，SslPlayHandler是PlayHandler的一个子类，就是重写了连接和出错时的处理，这里不多做阐述。\nPlayHandler PlayHandler的作用是解析http request的类型，然后根据不同类型来进行不同的处理，由于PlayHandler内处理的东西较多，这里先附上一张大体流程图以供读者参考\nmessageReceived messageReceived是一个Override方法，作用就是在netty消息传递至该handle时进行相应操作,方法代码如下\n@Override public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent messageEvent) throws Exception { if (Logger.isTraceEnabled()) { Logger.trace(\"messageReceived: begin\"); } final Object msg = messageEvent.getMessage(); //判断是否为HttpRequest的信息，不是则不进行处理 if (msg instanceof HttpRequest) { final HttpRequest nettyRequest = (HttpRequest) msg; // 若为websocket的初次握手请求，则进行websocket握手过程 if (HttpHeaders.Values.WEBSOCKET.equalsIgnoreCase(nettyRequest.getHeader(HttpHeaders.Names.UPGRADE))) { websocketHandshake(ctx, nettyRequest, messageEvent); return; } try { //将netty的request转为Play的request final Request request = parseRequest(ctx, nettyRequest, messageEvent); final Response response = new Response(); //Response.current为ThreadLocal类型，保证每个线程拥有单独Response Http.Response.current.set(response); // Buffered in memory output response.out = new ByteArrayOutputStream(); // Direct output (will be set later) response.direct = null; // Streamed output (using response.writeChunk) response.onWriteChunk(new Action\u003cObject\u003e() { public void invoke(Object result) { writeChunk(request, response, ctx, nettyRequest, result); } }); /* 查找Play插件(即继承了PlayPlugin抽象类的类)中是否有该request的实现方法，若存在，则用Play插件的实现 Play自带的插件实现有： CorePlugin实现了/@kill和/@status路径的访问流程 DBPlugin实现了/@db路径的访问流程 Evolutions实现了/@evolutions路径的访问流程 这里将插件的访问与其他访问分开最主要原因应该是插件访问不需要启动Play，而其他命令必须先调用Play.start来启动 */ boolean raw = Play.pluginCollection.rawInvocation(request, response); if (raw) { copyResponse(ctx, request, response, nettyRequest); } else { /* Invoker.invoke就是向Invoker类中的ScheduledThreadPoolExecutor提交任务并执行 使用ScheduledThreadPoolExecutor是因为可以定时，便于执行异步任务 Invoker类可以理解为是各个不同容器任务转向Play任务的一个转换类，他下面有2个静态内部类，分别为InvocationContext和Invocation InvocationContext内存放了当前request映射的controller类的annotation Invocation则为Play任务的基类，他的实现类有： Job：Play的异步任务 NettyInvocation：netty请求的实现类 ServletInvocation：Servlet容器中的实现类 WebSocketInvocation：websocket的实现类 */ Invoker.invoke(new NettyInvocation(request, response, ctx, nettyRequest, messageEvent)); } } catch (Exception ex) { //处理服务器错误 serve500(ex, ctx, nettyRequest); } } // 如果msg是websocket，则进行websocket接收 if (msg instanceof WebSocketFrame) { WebSocketFrame frame = (WebSocketFrame) msg; websocketFrameReceived(ctx, frame); } if (Logger.isTraceEnabled()) { Logger.trace(\"messageReceived: end\"); } } 可以很清楚的发现PlayHandler处理请求就是依靠了各个不同的Invocation实现来完成，那我们就来看看Invocation他是如何一步步处理请求的。\nInvocation Invocation是一个抽象类，继承了Runnable接口，它的run方法是这个类的核心。\npublic void run() { //waitInQueue是一个监视器，监视了这个invocation在队列中等待的时间 if (waitInQueue != null) { waitInQueue.stop(); } try { //预初始化，是对语言文件的清空 preInit(); //初始化 if (init()) { //运行执行前插件任务 before(); //处理request execute(); //运行执行后插件任务 after(); //成功执行后的处理 onSuccess(); } } catch (Suspend e) { //Suspend类让请求暂停 suspend(e); after(); } catch (Throwable e) { onException(e); } finally { _finally(); } } 这里面的preInit()、before()、after()是没有实现类的，用的就是Invocation类中的方法。我们先来看看Invocation类中对这些方法的实现，然后再来看看他的实现类对这些方法的修改\ninit public boolean init() { //设置当前线程的classloader Thread.currentThread().setContextClassLoader(Play.classloader); //检查是否为dev模式，是则检查文件是否修改，以进行热加载 Play.detectChanges(); //若Play未启动，启动 if (!Play.started) { if (Play.mode == Mode.PROD) { throw new UnexpectedException(\"Application is not started\"); } Play.start(); } //InvocationContext中添加当前映射方法的annotation InvocationContext.current.set(getInvocationContext()); return true; } Play.start可以先理解为启动Play服务，具体展开将在之后mvc章节详解\nexecute execute在Invocation类中是一个抽象方法，需要实现类完成自己的实现\nonSuccess public void onSuccess() throws Exception { Play.pluginCollection.onInvocationSuccess(); } 执行play插件中的执行成功方法\nonException public void onException(Throwable e) { Play.pluginCollection.onInvocationException(e); if (e instanceof PlayException) { throw (PlayException) e; } throw new UnexpectedException(e); } 执行play插件中的执行异常方法，然后抛出异常\nsuspend public void suspend(Suspend suspendRequest) { if (suspendRequest.task != null) { WaitForTasksCompletion.waitFor(suspendRequest.task, this); } else { Invoker.invoke(this, suspendRequest.timeout); } } 若暂停的请求有任务，那么调用WaitForTasksCompletion.waitFor进行等待，直到任务完成再继续运行请求 若没有任务，那就将请求通过ScheduledThreadPoolExecutor.schedule延时一段时间后执行\n_finally public void _finally() { Play.pluginCollection.invocationFinally(); InvocationContext.current.remove(); } 执行play插件中的invocationFinally方法\nNettyInvocation NettyInvocation是netty请求使用的实现类，我们来依次看看他对init,execute,onSuccess等方法的实现上相比Invocation改变了什么\nrun @Override public void run() { try { if (Logger.isTraceEnabled()) { Logger.trace(\"run: begin\"); } super.run(); } catch (Exception e) { serve500(e, ctx, nettyRequest); } if (Logger.isTraceEnabled()) { Logger.trace(\"run: end\"); } } NettyInvocation的run方法和基类唯一的差别就是包了一层try catch来处理服务器错误，这里有一点要注意，可以发现，NettyInvocation的run有一层try catch来处理500错误，PlayHandle中的messageReceived也有一层try catch来处理500错误，我的理解是前者是用来处理业务流程中的错误的，后者是为了防止意外错误引发整个服务器挂掉所以又套了一层做保险\ninit @Override public boolean init() { //设置当前线程的classloader Thread.currentThread().setContextClassLoader(Play.classloader); if (Logger.isTraceEnabled()) { Logger.trace(\"init: begin\"); } //设置当前线程的request和response Request.current.set(request); Response.current.set(response); try { //如果是dev模式检查路径更新 if (Play.mode == Play.Mode.DEV) { Router.detectChanges(Play.ctxPath); } //如果是prod模式且静态路径缓存有当前请求信息，则从缓存中获取 if (Play.mode == Play.Mode.PROD \u0026\u0026 staticPathsCache.containsKey(request.domain + \" \" + request.method + \" \" + request.path)) { RenderStatic rs = null; synchronized (staticPathsCache) { rs = staticPathsCache.get(request.domain + \" \" + request.method + \" \" + request.path); } //使用静态资源 serveStatic(rs, ctx, request, response, nettyRequest, event); if (Logger.isTraceEnabled()) { Logger.trace(\"init: end false\"); } return false; } //检查是否为静态资源 Router.routeOnlyStatic(request); super.init(); } catch (NotFound nf) { //返回404 serve404(nf, ctx, request, nettyRequest); if (Logger.isTraceEnabled()) { Logger.trace(\"init: end false\"); } return false; } catch (RenderStatic rs) { //使用静态资源 if (Play.mode == Play.Mode.PROD) { synchronized (staticPathsCache) { staticPathsCache.put(request.domain + \" \" + request.method + \" \" + request.path, rs); } } serveStatic(rs, ctx, request, response, nettyRequest, this.event); if (Logger.isTraceEnabled()) { Logger.trace(\"init: end false\"); } return false; } if (Logger.isTraceEnabled()) { Logger.trace(\"init: end true\"); } return true; } 可以看出，NettyInvocation的初始化就是在基类初始化之前判断request的路径，处理静态资源以及处理路径不存在的资源，这里也就说明了访问路由设置中的静态资源是不需要启动play服务的，是否意味着可以通过play搭建一个静态资源服务器？\nexecute @Override public void execute() throws Exception { //检查连接是否中断 if (!ctx.getChannel().isConnected()) { try { ctx.getChannel().close(); } catch (Throwable e) { // Ignore } return; } //渲染之前检查长度 saveExceededSizeError(nettyRequest, request, response); //运行 ActionInvoker.invoke(request, response); } ActionInvoker.invoke是play mvc的执行入口方法，这个在之后会进行详解\nsuccess @Override public void onSuccess() throws Exception { super.onSuccess(); if (response.chunked) { closeChunked(request, response, ctx, nettyRequest); } else { copyResponse(ctx, request, response, nettyRequest); } if (Logger.isTraceEnabled()) { Logger.trace(\"execute: end\"); } } 成功之后就判断是否是chunked类型的request，若是则关闭区块流并返回response，若不是则返回正常的response\nJob Job是Play任务的基类，用来处理异步任务，Job虽然继承了Invocation，但他并不会加入至Play的主线程池执行，Job有自己单独的线程池进行处理。因为Job可能需要一个返回值，所以它同时继承了Callable接口来提供返回值。 既然job能提供返回值，那真正起作用的方法就是call()而不是run(),我们来看一下他的call方法\npublic V call() { Monitor monitor = null; try { if (init()) { before(); V result = null; try { lastException = null; lastRun = System.currentTimeMillis(); monitor = MonitorFactory.start(getClass().getName()+\".doJob()\"); //执行任务并返回结果 result = doJobWithResult(); monitor.stop(); monitor = null; wasError = false; } catch (PlayException e) { throw e; } catch (Exception e) { StackTraceElement element = PlayException.getInterestingStrackTraceElement(e); if (element != null) { throw new JavaExecutionException(Play.classes.getApplicationClass(element.getClassName()), element.getLineNumber(), e); } throw e; } after(); return result; } } catch (Throwable e) { onException(e); } finally { if(monitor != null) { monitor.stop(); } _finally(); } return null; } 可以看出，job的call方法和Invocation的run方法其实差不多，中间执行job的代码其实就是execute方法的实现，但是有一点不同的是，job方法完成后不会调用onSuccess()方法。 这里只是提一下Job与Invocation类的关系，job任务的处理放在之后的插件篇再谈\nWebSocketInvocation WebSocketInvocation是websocket请求的实现类，我们来具体看下他对Invocation的方法做了怎么样的复写\ninit @Override public boolean init() { Http.Request.current.set(request); Http.Inbound.current.set(inbound); Http.Outbound.current.set(outbound); return super.init(); } 没什么大的变动，就是在当前线程下添加了出入站的通道信息\nexecute @Override public void execute() throws Exception { WebSocketInvoker.invoke(request, inbound, outbound); } execute方法就是将request请求，出入站通道传入WebSocketInvoker.invoke进行处理，WebSocketInvoker.invoke的代码如下，可以看出WebSocketInvoker.invoke方法也就是调用了ActionInvoker.invoke来对请求进行处理。\npublic static void invoke(Http.Request request, Http.Inbound inbound, Http.Outbound outbound) { try { if (Play.mode == Play.Mode.DEV) { WebSocketController.class.getDeclaredField(\"inbound\").set(null, Http.Inbound.current()); WebSocketController.class.getDeclaredField(\"outbound\").set(null, Http.Outbound.current()); WebSocketController.class.getDeclaredField(\"params\").set(null, Scope.Params.current()); WebSocketController.class.getDeclaredField(\"request\").set(null, Http.Request.current()); WebSocketController.class.getDeclaredField(\"session\").set(null, Scope.Session.current()); WebSocketController.class.getDeclaredField(\"validation\").set(null, Validation.current()); } //websocket是没有response的 ActionInvoker.invoke(request, null); }catch (PlayException e) { throw e; } catch (Exception e) { throw new UnexpectedException(e); } } onSuccess @Override public void onSuccess() throws Exception { outbound.close(); super.onSuccess(); } websocket只有当连接关闭时才会触发onSuccess方法，所以onSuccess相比Invocation也就多了一个关闭出站通道的操作\nServletInvocation ServletInvocation是当使用Servlet容器时的实现类，也就是将程序用war打包后放在Servlet容器后运行的类，ServletInvocation不直接基础于Invocation，而且继承于DirectInvocation，DirectInvocation继承了Invocation，DirectInvocation类添加了一个Suspend字段，用来处理线程暂停或等待操作。 因为在Servlet规范中请求线程的管理交由Servlet容器处理，所以ServletInvocation不是使用Invoker的ScheduledThreadPoolExecutor来执行的，那么在配置文件中设置play.pool数量对于使用Servlet容器的程序是无效的。 既然ServletInvocation不是使用Invoker中的线程池运行的，那他是从什么地方初始化这个类并运行的呢，这点将在本篇的ServletWrapper中再详解\n我们来看看ServletInvocation对Invocation中的方法进行了怎样的覆写\ninit @Override public boolean init() { try { return super.init(); } catch (NotFound e) { serve404(httpServletRequest, httpServletResponse, e); return false; } catch (RenderStatic r) { try { serveStatic(httpServletResponse, httpServletRequest, r); } catch (IOException e) { throw new UnexpectedException(e); } return false; } } 很简单的初始化，和NettyInvocation相比就是静态资源的缓存交由Servlet容器处理\nrun @Override public void run() { try { super.run(); } catch (Exception e) { serve500(e, httpServletRequest, httpServletResponse); return; } } 与NettyInvocation一样\nexecute @Override public void execute() throws Exception { ActionInvoker.invoke(request, response); copyResponse(request, response, httpServletRequest, httpServletResponse); } ServletInvocation在execute结束后就将结果返回，这里不知道为什么不和NettyInvocation统一一下，都在execute阶段返回结果或者都在onSuccess阶段返回结果\n使用netty的流程我们已经理清楚了，简单来说就是讲netty的请求处理后交由ActionInvoker.invoke来执行，ActionInvoker.invoke也是之后要研究的重点。\nServletWrapper 这篇的一开始我们以Server类为入口阐述了使用java命令直接运行时的运行过程，那么如果程序用war打包后放在Servlet容器中是如何运行的呢? 我们可以打开play程序包下resources/war的web.xml来看看默认的web.xml中是怎么配置的。\nplay.server.ServletWrapper play play.server.ServletWrapper\t可以看出监听器和servlet入口都是ServletWrapper，那我们从程序的创建开始一点点剖析play的运行过程\ncontextInitialized contextInitialized是在启动时自动加载，主要完成一些初始化的工作，代码如下\npublic void contextInitialized(ServletContextEvent e) { //standalonePlayServer表示这是否是一个独立服务器 Play.standalonePlayServer = false; ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader(); //这是程序根目录 String appDir = e.getServletContext().getRealPath(\"/WEB-INF/application\"); File root = new File(appDir); //play id在web.xml中配置 final String playId = System.getProperty(\"play.id\", e.getServletContext().getInitParameter(\"play.id\")); if (StringUtils.isEmpty(playId)) { throw new UnexpectedException(\"Please define a play.id parameter in your web.xml file. Without that parameter, play! cannot start your application. Please add a context-param into the WEB-INF/web.xml file.\"); } Play.frameworkPath = root.getParentFile(); //使用预编译的文件 Play.usePrecompiled = true; //初始化,初始化过程中会将运行模式强制改为prod Play.init(root, playId); //检查配置文件中模式是不是dev，是dev提示自动切换为prod Play.Mode mode = Play.Mode.valueOf(Play.configuration.getProperty(\"application.mode\", \"DEV\").toUpperCase()); if (mode.isDev()) { Logger.info(\"Forcing PROD mode because deploying as a war file.\"); } // Servlet 2.4手动加载路径 // Servlet 2.4 does not allow you to get the context path from the servletcontext... if (isGreaterThan(e.getServletContext(), 2, 4)) { loadRouter(e.getServletContext().getContextPath()); } Thread.currentThread().setContextClassLoader(oldClassLoader); } 初始化过程有2个地方需要注意\n不管配置文件中使用的是什么模式，放在Servlet容器中会统一改为prod 默认使用预编译模式加载 service service是servlet处理request的方法，我们先来看一下他的实现代码\n@Override protected void service(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException { //路由还没初始化时初始化路由 if (!routerInitializedWithContext) { loadRouter(httpServletRequest.getContextPath()); } if (Logger.isTraceEnabled()) { Logger.trace(\"ServletWrapper\u003eservice \" + httpServletRequest.getRequestURI()); } Request request = null; try { Response response = new Response(); response.out = new ByteArrayOutputStream(); Response.current.set(response); //httpServletRequest转为play的request request = parseRequest(httpServletRequest); if (Logger.isTraceEnabled()) { Logger.trace(\"ServletWrapper\u003eservice, request: \" + request); } //检查插件中是否有实现 boolean raw = Play.pluginCollection.rawInvocation(request, response); if (raw) { copyResponse(Request.current(), Response.current(), httpServletRequest, httpServletResponse); } else { //这里不是Invoker.invoke()方法，是invokeInThread Invoker.invokeInThread(new ServletInvocation(request, response, httpServletRequest, httpServletResponse)); } } catch (NotFound e) { //处理404 if (Logger.isTraceEnabled()) { Logger.trace(\"ServletWrapper\u003eservice, NotFound: \" + e); } serve404(httpServletRequest, httpServletResponse, e); return; } catch (RenderStatic e) { //处理静态资源 if (Logger.isTraceEnabled()) { Logger.trace(\"ServletWrapper\u003eservice, RenderStatic: \" + e); } serveStatic(httpServletResponse, httpServletRequest, e); return; } catch(URISyntaxException e) { //处理404 serve404(httpServletRequest, httpServletResponse, new NotFound(e.toString())); return; } catch (Throwable e) { throw new ServletException(e); } finally { //因为servlet的线程会复用，所以要手动删除当前线程内的值 Request.current.remove(); Response.current.remove(); Scope.Session.current.remove(); Scope.Params.current.remove(); Scope.Flash.current.remove(); Scope.RenderArgs.current.remove(); Scope.RouteArgs.current.remove(); CachedBoundActionMethodArgs.clear(); } } 看的出和PlayHandle其实就是一个处理方式，先转为play的request再扔到Invoker类中进行处理，那么我们来看看Invoker.invokeInThread的具体实现过程\npublic static void invokeInThread(DirectInvocation invocation) { boolean retry = true; while (retry) { invocation.run(); if (invocation.retry == null) { retry = false; } else { try { if (invocation.retry.task != null) { invocation.retry.task.get(); } else { Thread.sleep(invocation.retry.timeout); } } catch (Exception e) { throw new UnexpectedException(e); } retry = true; } } } invokeInThread就是在当前线程下运行invocation，如果遇到暂停或者等待任务完成就循环直到完成。\n要注意的一点是，Play 1.2.6未完成servlet模式下的websocket实现，所以如果要用websocket请用netty模式\n总结 至此，play的2种正常运行的启动逻辑已经分析完毕，play的启动过程还是在与不同的服务器运行容器打交道，如何将转化后的请求交由ActionInvoker来处理。 下一篇，我们先不看ActionInvoker的具体实现，先看看play对配置文件及路由的分析处理过程。\n","wordCount":"1803","inLanguage":"en","image":"https://example.org/avatar.png","datePublished":"2018-01-11T15:16:54Z","dateModified":"2018-01-11T15:16:54Z","author":{"@type":"Person","name":"luyanliang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://example.org/posts/play-framework/part2server%E4%B8%8Eservletwrapper/"},"publisher":{"@type":"Organization","name":"404 NOT FOUND","logo":{"@type":"ImageObject","url":"https://example.org/avatar.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://example.org/ accesskey=h title="404 NOT FOUND (Alt + H)">404 NOT FOUND</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://example.org/posts/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://example.org/>Home</a>&nbsp;»&nbsp;<a href=https://example.org/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Play framework源码解析 Part2:Server与ServletWrapper</h1><div class=post-meta><span title='2018-01-11 15:16:54 +0000 UTC'>January 11, 2018</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1803 words&nbsp;·&nbsp;luyanliang</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#server%e7%b1%bb aria-label=Server类>Server类</a><ul><li><a href=#httpserverpipelinefactory aria-label=HttpServerPipelineFactory>HttpServerPipelineFactory</a></li><li><a href=#sslhttpserverpipelinefactory aria-label=SslHttpServerPipelineFactory>SslHttpServerPipelineFactory</a></li><li><a href=#playhandler aria-label=PlayHandler>PlayHandler</a><ul><li><a href=#messagereceived aria-label=messageReceived>messageReceived</a></li><li><a href=#invocation aria-label=Invocation>Invocation</a><ul><li><a href=#nettyinvocation aria-label=NettyInvocation>NettyInvocation</a></li><li><a href=#job aria-label=Job>Job</a></li><li><a href=#websocketinvocation aria-label=WebSocketInvocation>WebSocketInvocation</a></li><li><a href=#servletinvocation aria-label=ServletInvocation>ServletInvocation</a></li></ul></li></ul></li></ul></li><li><a href=#servletwrapper aria-label=ServletWrapper>ServletWrapper</a><ul><li><a href=#contextinitialized aria-label=contextInitialized>contextInitialized</a></li><li><a href=#service aria-label=service>service</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach(e=>{const n=encodeURI(e.getAttribute("id")).toLowerCase(),t=document.querySelector(`.inner ul li a[href="#${n}"]`);if(e===activeElement){t.classList.add("active");const e=document.querySelector(".toc .inner"),n=t.offsetTop,s=e.clientHeight,o=t.clientHeight,i=n-s/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else t.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>在上一节中我们剖析了Play framework的启动原理，很容易就能发现Play framework的启动主入口在play.server.Server中，在本节，我们来一起看看Server类中主要发生了什么。</p><h1 id=server类>Server类<a hidden class=anchor aria-hidden=true href=#server类>#</a></h1><p>既然是程序运行的主入口，那么必然是由main方法进入的，Server类中的main方法十分简单。源码如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    File root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.path&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#75715e>//获取参数中的precompiled</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;precompiled&#34;</span>, <span style=color:#e6db74>&#34;false&#34;</span>).<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;true&#34;</span>)) {
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>usePrecompiled</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//获取参数中的writepid</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;writepid&#34;</span>, <span style=color:#e6db74>&#34;false&#34;</span>).<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;true&#34;</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//这个方法的作用是检查当前目录下是否存在server.pid文件，若存在表明当前已有程序在运行</span>
</span></span><span style=display:flex><span>        writePID(root);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Play类的初始化</span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>init</span>(root, System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;play.id&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;precompile&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Server类初始化</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Server(args);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Done.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>main方法执行的操作很简单:</p><ol><li>获取程序路径</li><li>检查是否存在precompiled参数</li><li>检查是否存在writepid参数，若存在则检查是否存在server.pid文件，若存在则表明已有程序在运行，不存在则将当前程序pid写入server.pid</li><li>play类初始化</li><li>检查是否存在precompile参数项，若存在表示是个预编译行为，结束运行，若没有则启动服务</li></ol><p>这其中最重要的便是Play类的初始化以及Server类的初始化
这里我们先来看Server类的初始化过程，现在可以先简单的将Play类的初始化理解为Play框架中一些常量的初始化以及日志、配置文件、路由信息等配置的读取。
这里贴一下Server类的初始化过程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Server</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//设置文件编码为UTF-8</span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>setProperty</span>(<span style=color:#e6db74>&#34;file.encoding&#34;</span>, <span style=color:#e6db74>&#34;utf-8&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//p为Play类初始化过程中读取的配置文件信息</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Properties p <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>configuration</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//获取参数中的http与https端口信息，若不存在则用配置文件中的http与https端口信息</span>
</span></span><span style=display:flex><span>    httpPort <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>parseInt</span>(getOpt(args, <span style=color:#e6db74>&#34;http.port&#34;</span>, p.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;http.port&#34;</span>, <span style=color:#e6db74>&#34;-1&#34;</span>)));
</span></span><span style=display:flex><span>    httpsPort <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>parseInt</span>(getOpt(args, <span style=color:#e6db74>&#34;https.port&#34;</span>, p.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;https.port&#34;</span>, <span style=color:#e6db74>&#34;-1&#34;</span>)));
</span></span><span style=display:flex><span>    <span style=color:#75715e>//若没有配置则设置默认端口为9000</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (httpPort <span style=color:#f92672>==</span> <span style=color:#f92672>-</span>1 <span style=color:#f92672>&amp;&amp;</span> httpsPort <span style=color:#f92672>==</span> <span style=color:#f92672>-</span>1) {
</span></span><span style=display:flex><span>        httpPort <span style=color:#f92672>=</span> 9000;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//http与https端口不能相同</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (httpPort <span style=color:#f92672>==</span> httpsPort) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Could not bind on https and http on the same port &#34;</span> <span style=color:#f92672>+</span> httpPort);
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>fatalServerErrorOccurred</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    InetAddress address <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    InetAddress secureAddress <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//获取配置文件中的默认http地址，若不存在则在系统参数中查找</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//之前还是参数配置大于配置文件，这里不知道为什么又变成了配置文件的优先级高于参数配置，很迷</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (p.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;http.address&#34;</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            address <span style=color:#f92672>=</span> InetAddress.<span style=color:#a6e22e>getByName</span>(p.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;http.address&#34;</span>));
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (System.<span style=color:#a6e22e>getProperties</span>().<span style=color:#a6e22e>containsKey</span>(<span style=color:#e6db74>&#34;http.address&#34;</span>)) {
</span></span><span style=display:flex><span>            address <span style=color:#f92672>=</span> InetAddress.<span style=color:#a6e22e>getByName</span>(System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;http.address&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>error</span>(e, <span style=color:#e6db74>&#34;Could not understand http.address&#34;</span>);
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>fatalServerErrorOccurred</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//同上，获取https地址</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (p.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;https.address&#34;</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            secureAddress <span style=color:#f92672>=</span> InetAddress.<span style=color:#a6e22e>getByName</span>(p.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;https.address&#34;</span>));
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (System.<span style=color:#a6e22e>getProperties</span>().<span style=color:#a6e22e>containsKey</span>(<span style=color:#e6db74>&#34;https.address&#34;</span>)) {
</span></span><span style=display:flex><span>            secureAddress <span style=color:#f92672>=</span> InetAddress.<span style=color:#a6e22e>getByName</span>(System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;https.address&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>error</span>(e, <span style=color:#e6db74>&#34;Could not understand https.address&#34;</span>);
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>fatalServerErrorOccurred</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//netty服务器启动类初始化，使用nio服务器，无限制线程池</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//这里的线程池是netty的主线程池与工作线程池，是处理连接的线程池，而Play实际执行业务操作的线程池在另一个地方配置</span>
</span></span><span style=display:flex><span>    ServerBootstrap bootstrap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerBootstrap(<span style=color:#66d9ef>new</span> NioServerSocketChannelFactory(
</span></span><span style=display:flex><span>            Executors.<span style=color:#a6e22e>newCachedThreadPool</span>(), Executors.<span style=color:#a6e22e>newCachedThreadPool</span>())
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//初始化http端口</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (httpPort <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span>1) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//设置管道工厂类</span>
</span></span><span style=display:flex><span>            bootstrap.<span style=color:#a6e22e>setPipelineFactory</span>(<span style=color:#66d9ef>new</span> HttpServerPipelineFactory());
</span></span><span style=display:flex><span>            <span style=color:#75715e>//绑定端口</span>
</span></span><span style=display:flex><span>            bootstrap.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(address, httpPort));
</span></span><span style=display:flex><span>            bootstrap.<span style=color:#a6e22e>setOption</span>(<span style=color:#e6db74>&#34;child.tcpNoDelay&#34;</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span> <span style=color:#f92672>==</span> Mode.<span style=color:#a6e22e>DEV</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (address <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Listening for HTTP on port %s (Waiting a first request to start) ...&#34;</span>, httpPort);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Listening for HTTP at %2$s:%1$s (Waiting a first request to start) ...&#34;</span>, httpPort, address);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (address <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Listening for HTTP on port %s ...&#34;</span>, httpPort);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Listening for HTTP at %2$s:%1$s  ...&#34;</span>, httpPort, address);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (ChannelException e) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Could not bind on port &#34;</span> <span style=color:#f92672>+</span> httpPort, e);
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>fatalServerErrorOccurred</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//下面是https端口服务器的启动过程，和http一致</span>
</span></span><span style=display:flex><span>    bootstrap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerBootstrap(<span style=color:#66d9ef>new</span> NioServerSocketChannelFactory(
</span></span><span style=display:flex><span>            Executors.<span style=color:#a6e22e>newCachedThreadPool</span>(), Executors.<span style=color:#a6e22e>newCachedThreadPool</span>())
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (httpsPort <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span>1) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//这里的管道工厂类变成了SslHttpServerPipelineFactory</span>
</span></span><span style=display:flex><span>            bootstrap.<span style=color:#a6e22e>setPipelineFactory</span>(<span style=color:#66d9ef>new</span> SslHttpServerPipelineFactory());
</span></span><span style=display:flex><span>            bootstrap.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(secureAddress, httpsPort));
</span></span><span style=display:flex><span>            bootstrap.<span style=color:#a6e22e>setOption</span>(<span style=color:#e6db74>&#34;child.tcpNoDelay&#34;</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span> <span style=color:#f92672>==</span> Mode.<span style=color:#a6e22e>DEV</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (secureAddress <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Listening for HTTPS on port %s (Waiting a first request to start) ...&#34;</span>, httpsPort);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Listening for HTTPS at %2$s:%1$s (Waiting a first request to start) ...&#34;</span>, httpsPort, secureAddress);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (secureAddress <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Listening for HTTPS on port %s ...&#34;</span>, httpsPort);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Listening for HTTPS at %2$s:%1$s  ...&#34;</span>, httpsPort, secureAddress);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (ChannelException e) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Could not bind on port &#34;</span> <span style=color:#f92672>+</span> httpsPort, e);
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>fatalServerErrorOccurred</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span> <span style=color:#f92672>==</span> Mode.<span style=color:#a6e22e>DEV</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// print this line to STDOUT - not using logger, so auto test runner will not block if logger is misconfigured (see #1222)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//输出启动成功，以便进行自动化测试</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;~ Server is up and running&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>server类的初始化没什么好说的，重点就在于那2个管道工厂类，HttpServerPipelineFactory与SslHttpServerPipelineFactory</p><h2 id=httpserverpipelinefactory>HttpServerPipelineFactory<a hidden class=anchor aria-hidden=true href=#httpserverpipelinefactory>#</a></h2><p>HttpServerPipelineFactory类作用就是为netty服务器增加了各个ChannelHandler。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HttpServerPipelineFactory</span> <span style=color:#66d9ef>implements</span> ChannelPipelineFactory {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ChannelPipeline <span style=color:#a6e22e>getPipeline</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Integer max <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>valueOf</span>(Play.<span style=color:#a6e22e>configuration</span>.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;play.netty.maxContentLength&#34;</span>, <span style=color:#e6db74>&#34;-1&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ChannelPipeline pipeline <span style=color:#f92672>=</span> pipeline();
</span></span><span style=display:flex><span>        PlayHandler playHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PlayHandler();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;flashPolicy&#34;</span>, <span style=color:#66d9ef>new</span> FlashPolicyHandler()); 
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;decoder&#34;</span>, <span style=color:#66d9ef>new</span> HttpRequestDecoder());
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;aggregator&#34;</span>, <span style=color:#66d9ef>new</span> StreamChunkAggregator(max));
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;encoder&#34;</span>, <span style=color:#66d9ef>new</span> HttpResponseEncoder());
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;chunkedWriter&#34;</span>, playHandler.<span style=color:#a6e22e>chunkedWriteHandler</span>);
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;handler&#34;</span>, playHandler);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pipeline;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>pipeline依次添加了flash处理器，http request解码器，流区块聚合器，http response编码器，区块写入器，play处理器<br>flash处理器和流区块聚合器这里暂且不作详细解析，读者可以理解为这2者的作用分别为传输flash流和合并请求头中有Transfer-Encoding:chunked的请求数据。<br>PlayHandler类是Play将netty接收到的request转换为play的request并真正开始业务处理的入口类，我们先暂时放下PlayHandler，先来看看SslHttpServerPipelineFactory做了什么</p><h2 id=sslhttpserverpipelinefactory>SslHttpServerPipelineFactory<a hidden class=anchor aria-hidden=true href=#sslhttpserverpipelinefactory>#</a></h2><p>SslHttpServerPipelineFactory是https使用的管道工厂类，他除了添加了一下处理器外，最重要的是根据配置创建了https的连接方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ChannelPipeline <span style=color:#a6e22e>getPipeline</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Integer max <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>valueOf</span>(Play.<span style=color:#a6e22e>configuration</span>.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;play.netty.maxContentLength&#34;</span>, <span style=color:#e6db74>&#34;-1&#34;</span>));
</span></span><span style=display:flex><span>        String mode <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>configuration</span>.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;play.netty.clientAuth&#34;</span>, <span style=color:#e6db74>&#34;none&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ChannelPipeline pipeline <span style=color:#f92672>=</span> pipeline();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Add SSL handler first to encrypt and decrypt everything.</span>
</span></span><span style=display:flex><span>        SSLEngine engine <span style=color:#f92672>=</span> SslHttpServerContextFactory.<span style=color:#a6e22e>getServerContext</span>().<span style=color:#a6e22e>createSSLEngine</span>();
</span></span><span style=display:flex><span>        engine.<span style=color:#a6e22e>setUseClientMode</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;want&#34;</span>.<span style=color:#a6e22e>equalsIgnoreCase</span>(mode)) {
</span></span><span style=display:flex><span>            engine.<span style=color:#a6e22e>setWantClientAuth</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;need&#34;</span>.<span style=color:#a6e22e>equalsIgnoreCase</span>(mode)) {
</span></span><span style=display:flex><span>            engine.<span style=color:#a6e22e>setNeedClientAuth</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        engine.<span style=color:#a6e22e>setEnableSessionCreation</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;flashPolicy&#34;</span>, <span style=color:#66d9ef>new</span> FlashPolicyHandler());
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;ssl&#34;</span>, <span style=color:#66d9ef>new</span> SslHandler(engine));
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;decoder&#34;</span>, <span style=color:#66d9ef>new</span> HttpRequestDecoder());
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;aggregator&#34;</span>, <span style=color:#66d9ef>new</span> StreamChunkAggregator(max));
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;encoder&#34;</span>, <span style=color:#66d9ef>new</span> HttpResponseEncoder());
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;chunkedWriter&#34;</span>, <span style=color:#66d9ef>new</span> ChunkedWriteHandler());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;handler&#34;</span>, <span style=color:#66d9ef>new</span> SslPlayHandler());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pipeline;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>在设置完SSLEngine后，SslHttpServerPipelineFactory在decoder处理器前加了一个SslHandler来处理连接，这里不是使用playHandler作为处理器，而是使用SslPlayHandler，SslPlayHandler是PlayHandler的一个子类，就是重写了连接和出错时的处理，这里不多做阐述。</p><h2 id=playhandler>PlayHandler<a hidden class=anchor aria-hidden=true href=#playhandler>#</a></h2><p>PlayHandler的作用是解析http request的类型，然后根据不同类型来进行不同的处理，由于PlayHandler内处理的东西较多，这里先附上一张大体流程图以供读者参考</p><p><img alt=PlayHandle流程图 loading=lazy src=https://s1.ax1x.com/2018/01/16/pdfssg.jpg></p><h3 id=messagereceived>messageReceived<a hidden class=anchor aria-hidden=true href=#messagereceived>#</a></h3><p>messageReceived是一个Override方法，作用就是在netty消息传递至该handle时进行相应操作,方法代码如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>messageReceived</span>(<span style=color:#66d9ef>final</span> ChannelHandlerContext ctx, <span style=color:#66d9ef>final</span> MessageEvent messageEvent) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;messageReceived: begin&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Object msg <span style=color:#f92672>=</span> messageEvent.<span style=color:#a6e22e>getMessage</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//判断是否为HttpRequest的信息，不是则不进行处理</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> HttpRequest) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> HttpRequest nettyRequest <span style=color:#f92672>=</span> (HttpRequest) msg;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若为websocket的初次握手请求，则进行websocket握手过程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (HttpHeaders.<span style=color:#a6e22e>Values</span>.<span style=color:#a6e22e>WEBSOCKET</span>.<span style=color:#a6e22e>equalsIgnoreCase</span>(nettyRequest.<span style=color:#a6e22e>getHeader</span>(HttpHeaders.<span style=color:#a6e22e>Names</span>.<span style=color:#a6e22e>UPGRADE</span>))) {
</span></span><span style=display:flex><span>            websocketHandshake(ctx, nettyRequest, messageEvent);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//将netty的request转为Play的request</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> Request request <span style=color:#f92672>=</span> parseRequest(ctx, nettyRequest, messageEvent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> Response response <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Response();
</span></span><span style=display:flex><span>            <span style=color:#75715e>//Response.current为ThreadLocal&lt;Response&gt;类型，保证每个线程拥有单独Response</span>
</span></span><span style=display:flex><span>            Http.<span style=color:#a6e22e>Response</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>set</span>(response);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Buffered in memory output</span>
</span></span><span style=display:flex><span>            response.<span style=color:#a6e22e>out</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Direct output (will be set later)</span>
</span></span><span style=display:flex><span>            response.<span style=color:#a6e22e>direct</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Streamed output (using response.writeChunk)</span>
</span></span><span style=display:flex><span>            response.<span style=color:#a6e22e>onWriteChunk</span>(<span style=color:#66d9ef>new</span> Action<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoke</span>(Object result) {
</span></span><span style=display:flex><span>                    writeChunk(request, response, ctx, nettyRequest, result);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                查找Play插件(即继承了PlayPlugin抽象类的类)中是否有该request的实现方法，若存在，则用Play插件的实现
</span></span></span><span style=display:flex><span><span style=color:#75715e>                Play自带的插件实现有：
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    CorePlugin实现了/@kill和/@status路径的访问流程
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    DBPlugin实现了/@db路径的访问流程
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    Evolutions实现了/@evolutions路径的访问流程
</span></span></span><span style=display:flex><span><span style=color:#75715e>                这里将插件的访问与其他访问分开最主要原因应该是插件访问不需要启动Play，而其他命令必须先调用Play.start来启动
</span></span></span><span style=display:flex><span><span style=color:#75715e>            */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> raw <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>pluginCollection</span>.<span style=color:#a6e22e>rawInvocation</span>(request, response);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (raw) {
</span></span><span style=display:flex><span>                copyResponse(ctx, request, response, nettyRequest);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    Invoker.invoke就是向Invoker类中的ScheduledThreadPoolExecutor提交任务并执行
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    使用ScheduledThreadPoolExecutor是因为可以定时，便于执行异步任务
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    Invoker类可以理解为是各个不同容器任务转向Play任务的一个转换类，他下面有2个静态内部类，分别为InvocationContext和Invocation
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    InvocationContext内存放了当前request映射的controller类的annotation
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    Invocation则为Play任务的基类，他的实现类有：
</span></span></span><span style=display:flex><span><span style=color:#75715e>                        Job：Play的异步任务
</span></span></span><span style=display:flex><span><span style=color:#75715e>                        NettyInvocation：netty请求的实现类
</span></span></span><span style=display:flex><span><span style=color:#75715e>                        ServletInvocation：Servlet容器中的实现类
</span></span></span><span style=display:flex><span><span style=color:#75715e>                        WebSocketInvocation：websocket的实现类
</span></span></span><span style=display:flex><span><span style=color:#75715e>                */</span>
</span></span><span style=display:flex><span>                Invoker.<span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>new</span> NettyInvocation(request, response, ctx, nettyRequest, messageEvent));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//处理服务器错误</span>
</span></span><span style=display:flex><span>            serve500(ex, ctx, nettyRequest);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果msg是websocket，则进行websocket接收</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> WebSocketFrame) {
</span></span><span style=display:flex><span>        WebSocketFrame frame <span style=color:#f92672>=</span> (WebSocketFrame) msg;
</span></span><span style=display:flex><span>        websocketFrameReceived(ctx, frame);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;messageReceived: end&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以很清楚的发现PlayHandler处理请求就是依靠了各个不同的Invocation实现来完成，那我们就来看看Invocation他是如何一步步处理请求的。</p><h3 id=invocation>Invocation<a hidden class=anchor aria-hidden=true href=#invocation>#</a></h3><p>Invocation是一个抽象类，继承了Runnable接口，它的run方法是这个类的核心。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//waitInQueue是一个监视器，监视了这个invocation在队列中等待的时间</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (waitInQueue <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        waitInQueue.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//预初始化，是对语言文件的清空</span>
</span></span><span style=display:flex><span>        preInit();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//初始化</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (init()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//运行执行前插件任务</span>
</span></span><span style=display:flex><span>            before();
</span></span><span style=display:flex><span>            <span style=color:#75715e>//处理request</span>
</span></span><span style=display:flex><span>            execute();
</span></span><span style=display:flex><span>            <span style=color:#75715e>//运行执行后插件任务</span>
</span></span><span style=display:flex><span>            after();
</span></span><span style=display:flex><span>            <span style=color:#75715e>//成功执行后的处理</span>
</span></span><span style=display:flex><span>            onSuccess();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Suspend e) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Suspend类让请求暂停</span>
</span></span><span style=display:flex><span>        suspend(e);
</span></span><span style=display:flex><span>        after();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>        onException(e);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        _finally();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里面的preInit()、before()、after()是没有实现类的，用的就是Invocation类中的方法。我们先来看看Invocation类中对这些方法的实现，然后再来看看他的实现类对这些方法的修改</p><ul><li>init</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//设置当前线程的classloader</span>
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>setContextClassLoader</span>(Play.<span style=color:#a6e22e>classloader</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//检查是否为dev模式，是则检查文件是否修改，以进行热加载</span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>detectChanges</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//若Play未启动，启动</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Play.<span style=color:#a6e22e>started</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span> <span style=color:#f92672>==</span> Mode.<span style=color:#a6e22e>PROD</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(<span style=color:#e6db74>&#34;Application is not started&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//InvocationContext中添加当前映射方法的annotation</span>
</span></span><span style=display:flex><span>    InvocationContext.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>set</span>(getInvocationContext());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>Play.start可以先理解为启动Play服务，具体展开将在之后mvc章节详解</em></p><ul><li>execute</li></ul><p>execute在Invocation类中是一个抽象方法，需要实现类完成自己的实现</p><ul><li>onSuccess</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSuccess</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>pluginCollection</span>.<span style=color:#a6e22e>onInvocationSuccess</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行play插件中的执行成功方法</p><ul><li>onException</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onException</span>(Throwable e) {
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>pluginCollection</span>.<span style=color:#a6e22e>onInvocationException</span>(e);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (e <span style=color:#66d9ef>instanceof</span> PlayException) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> (PlayException) e;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(e);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行play插件中的执行异常方法，然后抛出异常</p><ul><li>suspend</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>suspend</span>(Suspend suspendRequest) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (suspendRequest.<span style=color:#a6e22e>task</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        WaitForTasksCompletion.<span style=color:#a6e22e>waitFor</span>(suspendRequest.<span style=color:#a6e22e>task</span>, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        Invoker.<span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>this</span>, suspendRequest.<span style=color:#a6e22e>timeout</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>若暂停的请求有任务，那么调用WaitForTasksCompletion.waitFor进行等待，直到任务完成再继续运行请求
若没有任务，那就将请求通过ScheduledThreadPoolExecutor.schedule延时一段时间后执行</p><ul><li>_finally</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_finally</span>() {
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>pluginCollection</span>.<span style=color:#a6e22e>invocationFinally</span>();
</span></span><span style=display:flex><span>    InvocationContext.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行play插件中的invocationFinally方法</p><h4 id=nettyinvocation>NettyInvocation<a hidden class=anchor aria-hidden=true href=#nettyinvocation>#</a></h4><p>NettyInvocation是netty请求使用的实现类，我们来依次看看他对init,execute,onSuccess等方法的实现上相比Invocation改变了什么</p><ul><li>run</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;run: begin&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        serve500(e, ctx, nettyRequest);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;run: end&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>NettyInvocation的run方法和基类唯一的差别就是包了一层try catch来处理服务器错误，这里有一点要注意，可以发现，NettyInvocation的run有一层try catch来处理500错误，PlayHandle中的messageReceived也有一层try catch来处理500错误，我的理解是前者是用来处理业务流程中的错误的，后者是为了防止意外错误引发整个服务器挂掉所以又套了一层做保险</p><ul><li>init</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//设置当前线程的classloader</span>
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>setContextClassLoader</span>(Play.<span style=color:#a6e22e>classloader</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;init: begin&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//设置当前线程的request和response</span>
</span></span><span style=display:flex><span>    Request.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>set</span>(request);
</span></span><span style=display:flex><span>    Response.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>set</span>(response);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//如果是dev模式检查路径更新</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span> <span style=color:#f92672>==</span> Play.<span style=color:#a6e22e>Mode</span>.<span style=color:#a6e22e>DEV</span>) {
</span></span><span style=display:flex><span>            Router.<span style=color:#a6e22e>detectChanges</span>(Play.<span style=color:#a6e22e>ctxPath</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//如果是prod模式且静态路径缓存有当前请求信息，则从缓存中获取</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span> <span style=color:#f92672>==</span> Play.<span style=color:#a6e22e>Mode</span>.<span style=color:#a6e22e>PROD</span> <span style=color:#f92672>&amp;&amp;</span> staticPathsCache.<span style=color:#a6e22e>containsKey</span>(request.<span style=color:#a6e22e>domain</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> request.<span style=color:#a6e22e>method</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> request.<span style=color:#a6e22e>path</span>)) {
</span></span><span style=display:flex><span>            RenderStatic rs <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (staticPathsCache) {
</span></span><span style=display:flex><span>                rs <span style=color:#f92672>=</span> staticPathsCache.<span style=color:#a6e22e>get</span>(request.<span style=color:#a6e22e>domain</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> request.<span style=color:#a6e22e>method</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> request.<span style=color:#a6e22e>path</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>//使用静态资源</span>
</span></span><span style=display:flex><span>            serveStatic(rs, ctx, request, response, nettyRequest, event);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>                Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;init: end false&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//检查是否为静态资源</span>
</span></span><span style=display:flex><span>        Router.<span style=color:#a6e22e>routeOnlyStatic</span>(request);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (NotFound nf) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//返回404</span>
</span></span><span style=display:flex><span>        serve404(nf, ctx, request, nettyRequest);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;init: end false&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (RenderStatic rs) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//使用静态资源</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span> <span style=color:#f92672>==</span> Play.<span style=color:#a6e22e>Mode</span>.<span style=color:#a6e22e>PROD</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (staticPathsCache) {
</span></span><span style=display:flex><span>                staticPathsCache.<span style=color:#a6e22e>put</span>(request.<span style=color:#a6e22e>domain</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> request.<span style=color:#a6e22e>method</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> request.<span style=color:#a6e22e>path</span>, rs);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        serveStatic(rs, ctx, request, response, nettyRequest, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>event</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;init: end false&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;init: end true&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看出，NettyInvocation的初始化就是在基类初始化之前判断request的路径，处理静态资源以及处理路径不存在的资源，这里也就说明了访问路由设置中的静态资源是不需要启动play服务的，<del>是否意味着可以通过play搭建一个静态资源服务器？</del></p><ul><li>execute</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//检查连接是否中断</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ctx.<span style=color:#a6e22e>getChannel</span>().<span style=color:#a6e22e>isConnected</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            ctx.<span style=color:#a6e22e>getChannel</span>().<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Ignore</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//渲染之前检查长度</span>
</span></span><span style=display:flex><span>    saveExceededSizeError(nettyRequest, request, response);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//运行</span>
</span></span><span style=display:flex><span>    ActionInvoker.<span style=color:#a6e22e>invoke</span>(request, response);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ActionInvoker.invoke是play mvc的执行入口方法，这个在之后会进行详解</p><ul><li>success</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSuccess</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>onSuccess</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (response.<span style=color:#a6e22e>chunked</span>) {
</span></span><span style=display:flex><span>        closeChunked(request, response, ctx, nettyRequest);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        copyResponse(ctx, request, response, nettyRequest);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;execute: end&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>成功之后就判断是否是chunked类型的request，若是则关闭区块流并返回response，若不是则返回正常的response</p><h4 id=job>Job<a hidden class=anchor aria-hidden=true href=#job>#</a></h4><p>Job是Play任务的基类，用来处理异步任务，Job虽然继承了Invocation，但他并不会加入至Play的主线程池执行，Job有自己单独的线程池进行处理。因为Job可能需要一个返回值，所以它同时继承了Callable接口来提供返回值。
既然job能提供返回值，那真正起作用的方法就是call()而不是run(),我们来看一下他的call方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> V <span style=color:#a6e22e>call</span>() {
</span></span><span style=display:flex><span>    Monitor monitor <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (init()) {
</span></span><span style=display:flex><span>            before();
</span></span><span style=display:flex><span>            V result <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                lastException <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                lastRun <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>                monitor <span style=color:#f92672>=</span> MonitorFactory.<span style=color:#a6e22e>start</span>(getClass().<span style=color:#a6e22e>getName</span>()<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;.doJob()&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>//执行任务并返回结果</span>
</span></span><span style=display:flex><span>                result <span style=color:#f92672>=</span> doJobWithResult();
</span></span><span style=display:flex><span>                monitor.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>                monitor <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                wasError <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (PlayException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                StackTraceElement element <span style=color:#f92672>=</span> PlayException.<span style=color:#a6e22e>getInterestingStrackTraceElement</span>(e);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (element <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> JavaExecutionException(Play.<span style=color:#a6e22e>classes</span>.<span style=color:#a6e22e>getApplicationClass</span>(element.<span style=color:#a6e22e>getClassName</span>()), element.<span style=color:#a6e22e>getLineNumber</span>(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            after();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>        onException(e);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(monitor <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            monitor.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _finally();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看出，job的call方法和Invocation的run方法其实差不多，中间执行job的代码其实就是execute方法的实现，但是有一点不同的是，job方法完成后不会调用onSuccess()方法。
这里只是提一下Job与Invocation类的关系，job任务的处理放在之后的插件篇再谈</p><h4 id=websocketinvocation>WebSocketInvocation<a hidden class=anchor aria-hidden=true href=#websocketinvocation>#</a></h4><p>WebSocketInvocation是websocket请求的实现类，我们来具体看下他对Invocation的方法做了怎么样的复写</p><ul><li>init</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>    Http.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>set</span>(request);
</span></span><span style=display:flex><span>    Http.<span style=color:#a6e22e>Inbound</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>set</span>(inbound);
</span></span><span style=display:flex><span>    Http.<span style=color:#a6e22e>Outbound</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>set</span>(outbound);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>没什么大的变动，就是在当前线程下添加了出入站的通道信息</p><ul><li>execute</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    WebSocketInvoker.<span style=color:#a6e22e>invoke</span>(request, inbound, outbound);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>execute方法就是将request请求，出入站通道传入WebSocketInvoker.invoke进行处理，WebSocketInvoker.invoke的代码如下，可以看出WebSocketInvoker.invoke方法也就是调用了ActionInvoker.invoke来对请求进行处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoke</span>(Http.<span style=color:#a6e22e>Request</span> request, Http.<span style=color:#a6e22e>Inbound</span> inbound, Http.<span style=color:#a6e22e>Outbound</span> outbound) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span> <span style=color:#f92672>==</span> Play.<span style=color:#a6e22e>Mode</span>.<span style=color:#a6e22e>DEV</span>) {
</span></span><span style=display:flex><span>            WebSocketController.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;inbound&#34;</span>).<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>null</span>, Http.<span style=color:#a6e22e>Inbound</span>.<span style=color:#a6e22e>current</span>());
</span></span><span style=display:flex><span>            WebSocketController.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;outbound&#34;</span>).<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>null</span>, Http.<span style=color:#a6e22e>Outbound</span>.<span style=color:#a6e22e>current</span>());
</span></span><span style=display:flex><span>            WebSocketController.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;params&#34;</span>).<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>null</span>, Scope.<span style=color:#a6e22e>Params</span>.<span style=color:#a6e22e>current</span>());
</span></span><span style=display:flex><span>            WebSocketController.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;request&#34;</span>).<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>null</span>, Http.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>current</span>());
</span></span><span style=display:flex><span>            WebSocketController.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;session&#34;</span>).<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>null</span>, Scope.<span style=color:#a6e22e>Session</span>.<span style=color:#a6e22e>current</span>());
</span></span><span style=display:flex><span>            WebSocketController.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;validation&#34;</span>).<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>null</span>, Validation.<span style=color:#a6e22e>current</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//websocket是没有response的</span>
</span></span><span style=display:flex><span>        ActionInvoker.<span style=color:#a6e22e>invoke</span>(request, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    }<span style=color:#66d9ef>catch</span> (PlayException e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>onSuccess</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSuccess</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    outbound.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>onSuccess</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>websocket只有当连接关闭时才会触发onSuccess方法，所以onSuccess相比Invocation也就多了一个关闭出站通道的操作</p><h4 id=servletinvocation>ServletInvocation<a hidden class=anchor aria-hidden=true href=#servletinvocation>#</a></h4><p>ServletInvocation是当使用Servlet容器时的实现类，也就是将程序用war打包后放在Servlet容器后运行的类，ServletInvocation不直接基础于Invocation，而且继承于DirectInvocation，DirectInvocation继承了Invocation，DirectInvocation类添加了一个Suspend字段，用来处理线程暂停或等待操作。
因为在Servlet规范中请求线程的管理交由Servlet容器处理，所以ServletInvocation不是使用Invoker的ScheduledThreadPoolExecutor来执行的，那么在配置文件中设置play.pool数量对于使用Servlet容器的程序是无效的。
既然ServletInvocation不是使用Invoker中的线程池运行的，那他是从什么地方初始化这个类并运行的呢，这点将在本篇的ServletWrapper中再详解</p><p>我们来看看ServletInvocation对Invocation中的方法进行了怎样的覆写</p><ul><li>init</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (NotFound e) {
</span></span><span style=display:flex><span>        serve404(httpServletRequest, httpServletResponse, e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (RenderStatic r) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            serveStatic(httpServletResponse, httpServletRequest, r);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>很简单的初始化，和NettyInvocation相比就是静态资源的缓存交由Servlet容器处理</p><ul><li>run</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        serve500(e, httpServletRequest, httpServletResponse);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>与NettyInvocation一样</p><ul><li>execute</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    ActionInvoker.<span style=color:#a6e22e>invoke</span>(request, response);
</span></span><span style=display:flex><span>    copyResponse(request, response, httpServletRequest, httpServletResponse);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ServletInvocation在execute结束后就将结果返回，这里不知道为什么不和NettyInvocation统一一下，都在execute阶段返回结果或者都在onSuccess阶段返回结果</p><p><strong>使用netty的流程我们已经理清楚了，简单来说就是讲netty的请求处理后交由ActionInvoker.invoke来执行，ActionInvoker.invoke也是之后要研究的重点。</strong></p><h1 id=servletwrapper>ServletWrapper<a hidden class=anchor aria-hidden=true href=#servletwrapper>#</a></h1><p>这篇的一开始我们以Server类为入口阐述了使用java命令直接运行时的运行过程，那么如果程序用war打包后放在Servlet容器中是如何运行的呢?
我们可以打开play程序包下resources/war的web.xml来看看默认的web.xml中是怎么配置的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span>  <span style=color:#f92672>&lt;listener&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;listener-class&gt;</span>play.server.ServletWrapper<span style=color:#f92672>&lt;/listener-class&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/listener&gt;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;servlet&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet-name&gt;</span>play<span style=color:#f92672>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet-class&gt;</span>play.server.ServletWrapper<span style=color:#f92672>&lt;/servlet-class&gt;</span>	
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/servlet&gt;</span>
</span></span></code></pre></div><p>可以看出监听器和servlet入口都是ServletWrapper，那我们从程序的创建开始一点点剖析play的运行过程</p><h2 id=contextinitialized>contextInitialized<a hidden class=anchor aria-hidden=true href=#contextinitialized>#</a></h2><p>contextInitialized是在启动时自动加载，主要完成一些初始化的工作，代码如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>contextInitialized</span>(ServletContextEvent e) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//standalonePlayServer表示这是否是一个独立服务器</span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>standalonePlayServer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ClassLoader oldClassLoader <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getContextClassLoader</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//这是程序根目录</span>
</span></span><span style=display:flex><span>    String appDir <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>getServletContext</span>().<span style=color:#a6e22e>getRealPath</span>(<span style=color:#e6db74>&#34;/WEB-INF/application&#34;</span>);
</span></span><span style=display:flex><span>    File root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(appDir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//play id在web.xml中配置</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> String playId <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;play.id&#34;</span>, e.<span style=color:#a6e22e>getServletContext</span>().<span style=color:#a6e22e>getInitParameter</span>(<span style=color:#e6db74>&#34;play.id&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (StringUtils.<span style=color:#a6e22e>isEmpty</span>(playId)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(<span style=color:#e6db74>&#34;Please define a play.id parameter in your web.xml file. Without that parameter, play! cannot start your application. Please add a context-param into the WEB-INF/web.xml file.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>frameworkPath</span> <span style=color:#f92672>=</span> root.<span style=color:#a6e22e>getParentFile</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//使用预编译的文件</span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>usePrecompiled</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//初始化,初始化过程中会将运行模式强制改为prod</span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>init</span>(root, playId);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//检查配置文件中模式是不是dev，是dev提示自动切换为prod</span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>Mode</span> mode <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>Mode</span>.<span style=color:#a6e22e>valueOf</span>(Play.<span style=color:#a6e22e>configuration</span>.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.mode&#34;</span>, <span style=color:#e6db74>&#34;DEV&#34;</span>).<span style=color:#a6e22e>toUpperCase</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (mode.<span style=color:#a6e22e>isDev</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Forcing PROD mode because deploying as a war file.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Servlet 2.4手动加载路径</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Servlet 2.4 does not allow you to get the context path from the servletcontext...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isGreaterThan(e.<span style=color:#a6e22e>getServletContext</span>(), 2, 4)) {
</span></span><span style=display:flex><span>        loadRouter(e.<span style=color:#a6e22e>getServletContext</span>().<span style=color:#a6e22e>getContextPath</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>setContextClassLoader</span>(oldClassLoader);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>初始化过程有2个地方需要注意</p><ol><li>不管配置文件中使用的是什么模式，放在Servlet容器中会统一改为prod</li><li>默认使用预编译模式加载</li></ol><h2 id=service>service<a hidden class=anchor aria-hidden=true href=#service>#</a></h2><p>service是servlet处理request的方法，我们先来看一下他的实现代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>service</span>(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) <span style=color:#66d9ef>throws</span> ServletException, IOException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//路由还没初始化时初始化路由</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>routerInitializedWithContext) {
</span></span><span style=display:flex><span>        loadRouter(httpServletRequest.<span style=color:#a6e22e>getContextPath</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;ServletWrapper&gt;service &#34;</span> <span style=color:#f92672>+</span> httpServletRequest.<span style=color:#a6e22e>getRequestURI</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Request request <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        Response response <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Response();
</span></span><span style=display:flex><span>        response.<span style=color:#a6e22e>out</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream();
</span></span><span style=display:flex><span>        Response.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>set</span>(response);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//httpServletRequest转为play的request</span>
</span></span><span style=display:flex><span>        request <span style=color:#f92672>=</span> parseRequest(httpServletRequest);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;ServletWrapper&gt;service, request: &#34;</span> <span style=color:#f92672>+</span> request);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//检查插件中是否有实现</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> raw <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>pluginCollection</span>.<span style=color:#a6e22e>rawInvocation</span>(request, response);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (raw) {
</span></span><span style=display:flex><span>            copyResponse(Request.<span style=color:#a6e22e>current</span>(), Response.<span style=color:#a6e22e>current</span>(), httpServletRequest, httpServletResponse);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//这里不是Invoker.invoke()方法，是invokeInThread</span>
</span></span><span style=display:flex><span>            Invoker.<span style=color:#a6e22e>invokeInThread</span>(<span style=color:#66d9ef>new</span> ServletInvocation(request, response, httpServletRequest, httpServletResponse));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (NotFound e) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//处理404</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;ServletWrapper&gt;service, NotFound: &#34;</span> <span style=color:#f92672>+</span> e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        serve404(httpServletRequest, httpServletResponse, e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (RenderStatic e) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//处理静态资源</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;ServletWrapper&gt;service, RenderStatic: &#34;</span> <span style=color:#f92672>+</span> e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        serveStatic(httpServletResponse, httpServletRequest, e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span>(URISyntaxException e) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//处理404</span>
</span></span><span style=display:flex><span>        serve404(httpServletRequest, httpServletResponse, <span style=color:#66d9ef>new</span> NotFound(e.<span style=color:#a6e22e>toString</span>()));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ServletException(e);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//因为servlet的线程会复用，所以要手动删除当前线程内的值</span>
</span></span><span style=display:flex><span>        Request.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>        Response.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>        Scope.<span style=color:#a6e22e>Session</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>        Scope.<span style=color:#a6e22e>Params</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>        Scope.<span style=color:#a6e22e>Flash</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>        Scope.<span style=color:#a6e22e>RenderArgs</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>        Scope.<span style=color:#a6e22e>RouteArgs</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>        CachedBoundActionMethodArgs.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>看的出和PlayHandle其实就是一个处理方式，先转为play的request再扔到Invoker类中进行处理，那么我们来看看Invoker.invokeInThread的具体实现过程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invokeInThread</span>(DirectInvocation invocation) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> retry <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (retry) {
</span></span><span style=display:flex><span>        invocation.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (invocation.<span style=color:#a6e22e>retry</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            retry <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (invocation.<span style=color:#a6e22e>retry</span>.<span style=color:#a6e22e>task</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    invocation.<span style=color:#a6e22e>retry</span>.<span style=color:#a6e22e>task</span>.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>sleep</span>(invocation.<span style=color:#a6e22e>retry</span>.<span style=color:#a6e22e>timeout</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            retry <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>invokeInThread就是在当前线程下运行invocation，如果遇到暂停或者等待任务完成就循环直到完成。<br><strong>要注意的一点是，Play 1.2.6未完成servlet模式下的websocket实现，所以如果要用websocket请用netty模式</strong></p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>至此，play的2种正常运行的启动逻辑已经分析完毕，play的启动过程还是在与不同的服务器运行容器打交道，如何将转化后的请求交由ActionInvoker来处理。
下一篇，我们先不看ActionInvoker的具体实现，先看看play对配置文件及路由的分析处理过程。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://example.org/tags/program/>Program</a></li><li><a href=https://example.org/tags/backend/>Backend</a></li></ul><nav class=paginav><a class=prev href=https://example.org/posts/play-framework/part3play%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8/><span class=title>« Prev</span><br><span>Play framework源码解析 Part3:Play的初始化与启动</span>
</a><a class=next href=https://example.org/posts/play-framework/part1-play-framework-%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90/><span class=title>Next »</span><br><span>Play framework源码解析 Part1: Play framework 介绍、项目构成及启动脚本解析</span></a></nav></footer><script src=https://utteranc.es/client.js repo=asukaonly/asukaonly.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://example.org/>404 NOT FOUND</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>