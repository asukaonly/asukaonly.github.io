<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Play framework源码解析 Part3:Play的初始化与启动 | 404 NOT FOUND</title><meta name=keywords content="program,backend"><meta name=description content='在上一篇中，我们分析了play的2种启动方式，这一篇，我们来看看Play类的初始化过程

Play类
无论是Server还是ServletWrapper方式运行，在他们的入口中都会运行Play.init()来对Play类进行初始化。那在解析初始化之前，我们先来看看Play类是做什么的，它里面有什么重要的方法。
首先要明确的一点是，Play类是整个Play framework框架的管理、配置中心，它存放了大部分框架需要的成员变量，例如id,配置信息,所有加载的class,使用的插件管理器等等。下图就是Play类中的方法列表。

这其中加注释的几个方法是比较重要的，我们下面便来从init开始一点点剖析Play类中的各个方法。
Play的初始化
public static void init(File root, String id) {
    // Simple things
    Play.id = id;
    Play.started = false;
    Play.applicationPath = root;

    // 加载所有 play.static 中的记录的类
    initStaticStuff();
    //猜测play framework的路径
    guessFrameworkPath();

    // 读取配置文件
    readConfiguration();

    Play.classes = new ApplicationClasses();

    // 初始化日志
    Logger.init();
    String logLevel = configuration.getProperty("application.log", "INFO");

    //only override log-level if Logger was not configured manually
    if( !Logger.configuredManually) {
        Logger.setUp(logLevel);
    }
    Logger.recordCaller = Boolean.parseBoolean(configuration.getProperty("application.log.recordCaller", "false"));

    Logger.info("Starting %s", root.getAbsolutePath());
    //设置临时文件夹
    if (configuration.getProperty("play.tmp", "tmp").equals("none")) {
        tmpDir = null;
        Logger.debug("No tmp folder will be used (play.tmp is set to none)");
    } else {
        tmpDir = new File(configuration.getProperty("play.tmp", "tmp"));
        if (!tmpDir.isAbsolute()) {
            tmpDir = new File(applicationPath, tmpDir.getPath());
        }

        if (Logger.isTraceEnabled()) {
            Logger.trace("Using %s as tmp dir", Play.tmpDir);
        }

        if (!tmpDir.exists()) {
            try {
                if (readOnlyTmp) {
                    throw new Exception("ReadOnly tmp");
                }
                tmpDir.mkdirs();
            } catch (Throwable e) {
                tmpDir = null;
                Logger.warn("No tmp folder will be used (cannot create the tmp dir)");
            }
        }
    }

    // 设置运行模式
    try {
        mode = Mode.valueOf(configuration.getProperty("application.mode", "DEV").toUpperCase());
    } catch (IllegalArgumentException e) {
        Logger.error("Illegal mode &#39;%s&#39;, use either prod or dev", configuration.getProperty("application.mode"));
        fatalServerErrorOccurred();
    }
    if (usePrecompiled || forceProd) {
        mode = Mode.PROD;
    }

    // 获取http使用路径
    ctxPath = configuration.getProperty("http.path", ctxPath);

    // 设置文件路径
    VirtualFile appRoot = VirtualFile.open(applicationPath);
    roots.add(appRoot);
    javaPath = new CopyOnWriteArrayList<VirtualFile>();
    javaPath.add(appRoot.child("app"));
    javaPath.add(appRoot.child("conf"));

    // 设置模板路径
    if (appRoot.child("app/views").exists()) {
        templatesPath = new ArrayList<VirtualFile>(2);
        templatesPath.add(appRoot.child("app/views"));
    } else {
        templatesPath = new ArrayList<VirtualFile>(1);
    }

    // 设置路由文件
    routes = appRoot.child("conf/routes");

    // 设置模块路径
    modulesRoutes = new HashMap<String, VirtualFile>(16);

    // 加载模块
    loadModules();

    // 模板路径中加入框架自带的模板文件
    templatesPath.add(VirtualFile.open(new File(frameworkPath, "framework/templates")));

    // 初始化classloader
    classloader = new ApplicationClassloader();

    // Fix ctxPath
    if ("/".equals(Play.ctxPath)) {
        Play.ctxPath = "";
    }

    // 设置cookie域名
    Http.Cookie.defaultDomain = configuration.getProperty("application.defaultCookieDomain", null);
    if (Http.Cookie.defaultDomain!=null) {
        Logger.info("Using default cookie domain: " + Http.Cookie.defaultDomain);
    }

    // 加载插件
    pluginCollection.loadPlugins();

    // 如果是prod直接启动
    if (mode == Mode.PROD || System.getProperty("precompile") != null) {
        mode = Mode.PROD;
        //预编译
        if (preCompile() && System.getProperty("precompile") == null) {
            start();
        } else {
            return;
        }
    } else {
        Logger.warn("You&#39;re running Play! in DEV mode");
    }

    pluginCollection.onApplicationReady();

    Play.initialized = true;
}
如上面的代码所示，初始化过程主要的顺序为：'><meta name=author content="asuka"><link rel=canonical href=https://example.org/posts/play-framework/part3play%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://example.org/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://example.org/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://example.org/avatar.png><link rel=apple-touch-icon href=https://example.org/avatar.png><link rel=mask-icon href=https://example.org/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://example.org/posts/play-framework/part3play%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://example.org/posts/play-framework/part3play%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8/"><meta property="og:site_name" content="404 NOT FOUND"><meta property="og:title" content="Play framework源码解析 Part3:Play的初始化与启动"><meta property="og:description" content='在上一篇中，我们分析了play的2种启动方式，这一篇，我们来看看Play类的初始化过程
Play类 无论是Server还是ServletWrapper方式运行，在他们的入口中都会运行Play.init()来对Play类进行初始化。那在解析初始化之前，我们先来看看Play类是做什么的，它里面有什么重要的方法。 首先要明确的一点是，Play类是整个Play framework框架的管理、配置中心，它存放了大部分框架需要的成员变量，例如id,配置信息,所有加载的class,使用的插件管理器等等。下图就是Play类中的方法列表。 这其中加注释的几个方法是比较重要的，我们下面便来从init开始一点点剖析Play类中的各个方法。
Play的初始化 public static void init(File root, String id) { // Simple things Play.id = id; Play.started = false; Play.applicationPath = root; // 加载所有 play.static 中的记录的类 initStaticStuff(); //猜测play framework的路径 guessFrameworkPath(); // 读取配置文件 readConfiguration(); Play.classes = new ApplicationClasses(); // 初始化日志 Logger.init(); String logLevel = configuration.getProperty("application.log", "INFO"); //only override log-level if Logger was not configured manually if( !Logger.configuredManually) { Logger.setUp(logLevel); } Logger.recordCaller = Boolean.parseBoolean(configuration.getProperty("application.log.recordCaller", "false")); Logger.info("Starting %s", root.getAbsolutePath()); //设置临时文件夹 if (configuration.getProperty("play.tmp", "tmp").equals("none")) { tmpDir = null; Logger.debug("No tmp folder will be used (play.tmp is set to none)"); } else { tmpDir = new File(configuration.getProperty("play.tmp", "tmp")); if (!tmpDir.isAbsolute()) { tmpDir = new File(applicationPath, tmpDir.getPath()); } if (Logger.isTraceEnabled()) { Logger.trace("Using %s as tmp dir", Play.tmpDir); } if (!tmpDir.exists()) { try { if (readOnlyTmp) { throw new Exception("ReadOnly tmp"); } tmpDir.mkdirs(); } catch (Throwable e) { tmpDir = null; Logger.warn("No tmp folder will be used (cannot create the tmp dir)"); } } } // 设置运行模式 try { mode = Mode.valueOf(configuration.getProperty("application.mode", "DEV").toUpperCase()); } catch (IllegalArgumentException e) { Logger.error("Illegal mode &#39;%s&#39;, use either prod or dev", configuration.getProperty("application.mode")); fatalServerErrorOccurred(); } if (usePrecompiled || forceProd) { mode = Mode.PROD; } // 获取http使用路径 ctxPath = configuration.getProperty("http.path", ctxPath); // 设置文件路径 VirtualFile appRoot = VirtualFile.open(applicationPath); roots.add(appRoot); javaPath = new CopyOnWriteArrayList<VirtualFile>(); javaPath.add(appRoot.child("app")); javaPath.add(appRoot.child("conf")); // 设置模板路径 if (appRoot.child("app/views").exists()) { templatesPath = new ArrayList<VirtualFile>(2); templatesPath.add(appRoot.child("app/views")); } else { templatesPath = new ArrayList<VirtualFile>(1); } // 设置路由文件 routes = appRoot.child("conf/routes"); // 设置模块路径 modulesRoutes = new HashMap<String, VirtualFile>(16); // 加载模块 loadModules(); // 模板路径中加入框架自带的模板文件 templatesPath.add(VirtualFile.open(new File(frameworkPath, "framework/templates"))); // 初始化classloader classloader = new ApplicationClassloader(); // Fix ctxPath if ("/".equals(Play.ctxPath)) { Play.ctxPath = ""; } // 设置cookie域名 Http.Cookie.defaultDomain = configuration.getProperty("application.defaultCookieDomain", null); if (Http.Cookie.defaultDomain!=null) { Logger.info("Using default cookie domain: " + Http.Cookie.defaultDomain); } // 加载插件 pluginCollection.loadPlugins(); // 如果是prod直接启动 if (mode == Mode.PROD || System.getProperty("precompile") != null) { mode = Mode.PROD; //预编译 if (preCompile() && System.getProperty("precompile") == null) { start(); } else { return; } } else { Logger.warn("You&#39;re running Play! in DEV mode"); } pluginCollection.onApplicationReady(); Play.initialized = true; } 如上面的代码所示，初始化过程主要的顺序为：'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-20T15:52:41+00:00"><meta property="article:modified_time" content="2018-01-20T15:52:41+00:00"><meta property="article:tag" content="Program"><meta property="article:tag" content="Backend"><meta property="og:image" content="https://example.org/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://example.org/avatar.png"><meta name=twitter:title content="Play framework源码解析 Part3:Play的初始化与启动"><meta name=twitter:description content='在上一篇中，我们分析了play的2种启动方式，这一篇，我们来看看Play类的初始化过程

Play类
无论是Server还是ServletWrapper方式运行，在他们的入口中都会运行Play.init()来对Play类进行初始化。那在解析初始化之前，我们先来看看Play类是做什么的，它里面有什么重要的方法。
首先要明确的一点是，Play类是整个Play framework框架的管理、配置中心，它存放了大部分框架需要的成员变量，例如id,配置信息,所有加载的class,使用的插件管理器等等。下图就是Play类中的方法列表。

这其中加注释的几个方法是比较重要的，我们下面便来从init开始一点点剖析Play类中的各个方法。
Play的初始化
public static void init(File root, String id) {
    // Simple things
    Play.id = id;
    Play.started = false;
    Play.applicationPath = root;

    // 加载所有 play.static 中的记录的类
    initStaticStuff();
    //猜测play framework的路径
    guessFrameworkPath();

    // 读取配置文件
    readConfiguration();

    Play.classes = new ApplicationClasses();

    // 初始化日志
    Logger.init();
    String logLevel = configuration.getProperty("application.log", "INFO");

    //only override log-level if Logger was not configured manually
    if( !Logger.configuredManually) {
        Logger.setUp(logLevel);
    }
    Logger.recordCaller = Boolean.parseBoolean(configuration.getProperty("application.log.recordCaller", "false"));

    Logger.info("Starting %s", root.getAbsolutePath());
    //设置临时文件夹
    if (configuration.getProperty("play.tmp", "tmp").equals("none")) {
        tmpDir = null;
        Logger.debug("No tmp folder will be used (play.tmp is set to none)");
    } else {
        tmpDir = new File(configuration.getProperty("play.tmp", "tmp"));
        if (!tmpDir.isAbsolute()) {
            tmpDir = new File(applicationPath, tmpDir.getPath());
        }

        if (Logger.isTraceEnabled()) {
            Logger.trace("Using %s as tmp dir", Play.tmpDir);
        }

        if (!tmpDir.exists()) {
            try {
                if (readOnlyTmp) {
                    throw new Exception("ReadOnly tmp");
                }
                tmpDir.mkdirs();
            } catch (Throwable e) {
                tmpDir = null;
                Logger.warn("No tmp folder will be used (cannot create the tmp dir)");
            }
        }
    }

    // 设置运行模式
    try {
        mode = Mode.valueOf(configuration.getProperty("application.mode", "DEV").toUpperCase());
    } catch (IllegalArgumentException e) {
        Logger.error("Illegal mode &#39;%s&#39;, use either prod or dev", configuration.getProperty("application.mode"));
        fatalServerErrorOccurred();
    }
    if (usePrecompiled || forceProd) {
        mode = Mode.PROD;
    }

    // 获取http使用路径
    ctxPath = configuration.getProperty("http.path", ctxPath);

    // 设置文件路径
    VirtualFile appRoot = VirtualFile.open(applicationPath);
    roots.add(appRoot);
    javaPath = new CopyOnWriteArrayList<VirtualFile>();
    javaPath.add(appRoot.child("app"));
    javaPath.add(appRoot.child("conf"));

    // 设置模板路径
    if (appRoot.child("app/views").exists()) {
        templatesPath = new ArrayList<VirtualFile>(2);
        templatesPath.add(appRoot.child("app/views"));
    } else {
        templatesPath = new ArrayList<VirtualFile>(1);
    }

    // 设置路由文件
    routes = appRoot.child("conf/routes");

    // 设置模块路径
    modulesRoutes = new HashMap<String, VirtualFile>(16);

    // 加载模块
    loadModules();

    // 模板路径中加入框架自带的模板文件
    templatesPath.add(VirtualFile.open(new File(frameworkPath, "framework/templates")));

    // 初始化classloader
    classloader = new ApplicationClassloader();

    // Fix ctxPath
    if ("/".equals(Play.ctxPath)) {
        Play.ctxPath = "";
    }

    // 设置cookie域名
    Http.Cookie.defaultDomain = configuration.getProperty("application.defaultCookieDomain", null);
    if (Http.Cookie.defaultDomain!=null) {
        Logger.info("Using default cookie domain: " + Http.Cookie.defaultDomain);
    }

    // 加载插件
    pluginCollection.loadPlugins();

    // 如果是prod直接启动
    if (mode == Mode.PROD || System.getProperty("precompile") != null) {
        mode = Mode.PROD;
        //预编译
        if (preCompile() && System.getProperty("precompile") == null) {
            start();
        } else {
            return;
        }
    } else {
        Logger.warn("You&#39;re running Play! in DEV mode");
    }

    pluginCollection.onApplicationReady();

    Play.initialized = true;
}
如上面的代码所示，初始化过程主要的顺序为：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://example.org/posts/"},{"@type":"ListItem","position":2,"name":"Play framework源码解析 Part3:Play的初始化与启动","item":"https://example.org/posts/play-framework/part3play%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Play framework源码解析 Part3:Play的初始化与启动","name":"Play framework源码解析 Part3:Play的初始化与启动","description":"在上一篇中，我们分析了play的2种启动方式，这一篇，我们来看看Play类的初始化过程\nPlay类 无论是Server还是ServletWrapper方式运行，在他们的入口中都会运行Play.init()来对Play类进行初始化。那在解析初始化之前，我们先来看看Play类是做什么的，它里面有什么重要的方法。 首先要明确的一点是，Play类是整个Play framework框架的管理、配置中心，它存放了大部分框架需要的成员变量，例如id,配置信息,所有加载的class,使用的插件管理器等等。下图就是Play类中的方法列表。 这其中加注释的几个方法是比较重要的，我们下面便来从init开始一点点剖析Play类中的各个方法。\nPlay的初始化 public static void init(File root, String id) { // Simple things Play.id = id; Play.started = false; Play.applicationPath = root; // 加载所有 play.static 中的记录的类 initStaticStuff(); //猜测play framework的路径 guessFrameworkPath(); // 读取配置文件 readConfiguration(); Play.classes = new ApplicationClasses(); // 初始化日志 Logger.init(); String logLevel = configuration.getProperty(\u0026#34;application.log\u0026#34;, \u0026#34;INFO\u0026#34;); //only override log-level if Logger was not configured manually if( !Logger.configuredManually) { Logger.setUp(logLevel); } Logger.recordCaller = Boolean.parseBoolean(configuration.getProperty(\u0026#34;application.log.recordCaller\u0026#34;, \u0026#34;false\u0026#34;)); Logger.info(\u0026#34;Starting %s\u0026#34;, root.getAbsolutePath()); //设置临时文件夹 if (configuration.getProperty(\u0026#34;play.tmp\u0026#34;, \u0026#34;tmp\u0026#34;).equals(\u0026#34;none\u0026#34;)) { tmpDir = null; Logger.debug(\u0026#34;No tmp folder will be used (play.tmp is set to none)\u0026#34;); } else { tmpDir = new File(configuration.getProperty(\u0026#34;play.tmp\u0026#34;, \u0026#34;tmp\u0026#34;)); if (!tmpDir.isAbsolute()) { tmpDir = new File(applicationPath, tmpDir.getPath()); } if (Logger.isTraceEnabled()) { Logger.trace(\u0026#34;Using %s as tmp dir\u0026#34;, Play.tmpDir); } if (!tmpDir.exists()) { try { if (readOnlyTmp) { throw new Exception(\u0026#34;ReadOnly tmp\u0026#34;); } tmpDir.mkdirs(); } catch (Throwable e) { tmpDir = null; Logger.warn(\u0026#34;No tmp folder will be used (cannot create the tmp dir)\u0026#34;); } } } // 设置运行模式 try { mode = Mode.valueOf(configuration.getProperty(\u0026#34;application.mode\u0026#34;, \u0026#34;DEV\u0026#34;).toUpperCase()); } catch (IllegalArgumentException e) { Logger.error(\u0026#34;Illegal mode \u0026#39;%s\u0026#39;, use either prod or dev\u0026#34;, configuration.getProperty(\u0026#34;application.mode\u0026#34;)); fatalServerErrorOccurred(); } if (usePrecompiled || forceProd) { mode = Mode.PROD; } // 获取http使用路径 ctxPath = configuration.getProperty(\u0026#34;http.path\u0026#34;, ctxPath); // 设置文件路径 VirtualFile appRoot = VirtualFile.open(applicationPath); roots.add(appRoot); javaPath = new CopyOnWriteArrayList\u0026lt;VirtualFile\u0026gt;(); javaPath.add(appRoot.child(\u0026#34;app\u0026#34;)); javaPath.add(appRoot.child(\u0026#34;conf\u0026#34;)); // 设置模板路径 if (appRoot.child(\u0026#34;app/views\u0026#34;).exists()) { templatesPath = new ArrayList\u0026lt;VirtualFile\u0026gt;(2); templatesPath.add(appRoot.child(\u0026#34;app/views\u0026#34;)); } else { templatesPath = new ArrayList\u0026lt;VirtualFile\u0026gt;(1); } // 设置路由文件 routes = appRoot.child(\u0026#34;conf/routes\u0026#34;); // 设置模块路径 modulesRoutes = new HashMap\u0026lt;String, VirtualFile\u0026gt;(16); // 加载模块 loadModules(); // 模板路径中加入框架自带的模板文件 templatesPath.add(VirtualFile.open(new File(frameworkPath, \u0026#34;framework/templates\u0026#34;))); // 初始化classloader classloader = new ApplicationClassloader(); // Fix ctxPath if (\u0026#34;/\u0026#34;.equals(Play.ctxPath)) { Play.ctxPath = \u0026#34;\u0026#34;; } // 设置cookie域名 Http.Cookie.defaultDomain = configuration.getProperty(\u0026#34;application.defaultCookieDomain\u0026#34;, null); if (Http.Cookie.defaultDomain!=null) { Logger.info(\u0026#34;Using default cookie domain: \u0026#34; + Http.Cookie.defaultDomain); } // 加载插件 pluginCollection.loadPlugins(); // 如果是prod直接启动 if (mode == Mode.PROD || System.getProperty(\u0026#34;precompile\u0026#34;) != null) { mode = Mode.PROD; //预编译 if (preCompile() \u0026amp;\u0026amp; System.getProperty(\u0026#34;precompile\u0026#34;) == null) { start(); } else { return; } } else { Logger.warn(\u0026#34;You\u0026#39;re running Play! in DEV mode\u0026#34;); } pluginCollection.onApplicationReady(); Play.initialized = true; } 如上面的代码所示，初始化过程主要的顺序为：\n","keywords":["program","backend"],"articleBody":"在上一篇中，我们分析了play的2种启动方式，这一篇，我们来看看Play类的初始化过程\nPlay类 无论是Server还是ServletWrapper方式运行，在他们的入口中都会运行Play.init()来对Play类进行初始化。那在解析初始化之前，我们先来看看Play类是做什么的，它里面有什么重要的方法。 首先要明确的一点是，Play类是整个Play framework框架的管理、配置中心，它存放了大部分框架需要的成员变量，例如id,配置信息,所有加载的class,使用的插件管理器等等。下图就是Play类中的方法列表。 这其中加注释的几个方法是比较重要的，我们下面便来从init开始一点点剖析Play类中的各个方法。\nPlay的初始化 public static void init(File root, String id) { // Simple things Play.id = id; Play.started = false; Play.applicationPath = root; // 加载所有 play.static 中的记录的类 initStaticStuff(); //猜测play framework的路径 guessFrameworkPath(); // 读取配置文件 readConfiguration(); Play.classes = new ApplicationClasses(); // 初始化日志 Logger.init(); String logLevel = configuration.getProperty(\"application.log\", \"INFO\"); //only override log-level if Logger was not configured manually if( !Logger.configuredManually) { Logger.setUp(logLevel); } Logger.recordCaller = Boolean.parseBoolean(configuration.getProperty(\"application.log.recordCaller\", \"false\")); Logger.info(\"Starting %s\", root.getAbsolutePath()); //设置临时文件夹 if (configuration.getProperty(\"play.tmp\", \"tmp\").equals(\"none\")) { tmpDir = null; Logger.debug(\"No tmp folder will be used (play.tmp is set to none)\"); } else { tmpDir = new File(configuration.getProperty(\"play.tmp\", \"tmp\")); if (!tmpDir.isAbsolute()) { tmpDir = new File(applicationPath, tmpDir.getPath()); } if (Logger.isTraceEnabled()) { Logger.trace(\"Using %s as tmp dir\", Play.tmpDir); } if (!tmpDir.exists()) { try { if (readOnlyTmp) { throw new Exception(\"ReadOnly tmp\"); } tmpDir.mkdirs(); } catch (Throwable e) { tmpDir = null; Logger.warn(\"No tmp folder will be used (cannot create the tmp dir)\"); } } } // 设置运行模式 try { mode = Mode.valueOf(configuration.getProperty(\"application.mode\", \"DEV\").toUpperCase()); } catch (IllegalArgumentException e) { Logger.error(\"Illegal mode '%s', use either prod or dev\", configuration.getProperty(\"application.mode\")); fatalServerErrorOccurred(); } if (usePrecompiled || forceProd) { mode = Mode.PROD; } // 获取http使用路径 ctxPath = configuration.getProperty(\"http.path\", ctxPath); // 设置文件路径 VirtualFile appRoot = VirtualFile.open(applicationPath); roots.add(appRoot); javaPath = new CopyOnWriteArrayList\u003cVirtualFile\u003e(); javaPath.add(appRoot.child(\"app\")); javaPath.add(appRoot.child(\"conf\")); // 设置模板路径 if (appRoot.child(\"app/views\").exists()) { templatesPath = new ArrayList\u003cVirtualFile\u003e(2); templatesPath.add(appRoot.child(\"app/views\")); } else { templatesPath = new ArrayList\u003cVirtualFile\u003e(1); } // 设置路由文件 routes = appRoot.child(\"conf/routes\"); // 设置模块路径 modulesRoutes = new HashMap\u003cString, VirtualFile\u003e(16); // 加载模块 loadModules(); // 模板路径中加入框架自带的模板文件 templatesPath.add(VirtualFile.open(new File(frameworkPath, \"framework/templates\"))); // 初始化classloader classloader = new ApplicationClassloader(); // Fix ctxPath if (\"/\".equals(Play.ctxPath)) { Play.ctxPath = \"\"; } // 设置cookie域名 Http.Cookie.defaultDomain = configuration.getProperty(\"application.defaultCookieDomain\", null); if (Http.Cookie.defaultDomain!=null) { Logger.info(\"Using default cookie domain: \" + Http.Cookie.defaultDomain); } // 加载插件 pluginCollection.loadPlugins(); // 如果是prod直接启动 if (mode == Mode.PROD || System.getProperty(\"precompile\") != null) { mode = Mode.PROD; //预编译 if (preCompile() \u0026\u0026 System.getProperty(\"precompile\") == null) { start(); } else { return; } } else { Logger.warn(\"You're running Play! in DEV mode\"); } pluginCollection.onApplicationReady(); Play.initialized = true; } 如上面的代码所示，初始化过程主要的顺序为：\n加载所有play.static中记录的类 获取框架路径 读取配置文件 初始化日志 获取java文件、模板文件路径 加载模块 加载插件 若为prod模式进行预编译 我们来依次看看Play在这些过程中做了什么事情。\n加载play.static Play在初始化过程中会调用initStaticStuff()方法来检查代码目录下是否存在play.static文件，如果存在，那么就逐行读取文件中记录的类，并通过反射加载类中的静态初始化代码段。至于作用吗，不知道有什么用，这段代码的优先级太高了，早于初始化过程运行，若在初始化过程结束后运行还可以用来覆写Play类中的配置信息。或者自己写插件然后在play.static中初始化插件依赖？或者绑定新的数据源？\npublic static void initStaticStuff() { // Play! plugings Enumeration\u003cURL\u003e urls = null; try { urls = Play.class.getClassLoader().getResources(\"play.static\"); } catch (Exception e) { } while (urls != null \u0026\u0026 urls.hasMoreElements()) { URL url = urls.nextElement(); try { BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"utf-8\")); String line = null; while ((line = reader.readLine()) != null) { try { Class.forName(line); } catch (Exception e) { Logger.warn(\"! Cannot init static: \" + line); } } } catch (Exception ex) { Logger.error(ex, \"Cannot load %s\", url); } } } 获取框架路径 获取框架路径很简单，就是判断是用jar模式运行还是直接用文件运行，然后读取对应的路径\npublic static void guessFrameworkPath() { // Guess the framework path try { URL versionUrl = Play.class.getResource(\"/play/version\"); // Read the content of the file Play.version = new LineNumberReader(new InputStreamReader(versionUrl.openStream())).readLine(); // This is used only by the embedded server (Mina, Netty, Jetty etc) URI uri = new URI(versionUrl.toString().replace(\" \", \"%20\")); if (frameworkPath == null || !frameworkPath.exists()) { if (uri.getScheme().equals(\"jar\")) { String jarPath = uri.getSchemeSpecificPart().substring(5, uri.getSchemeSpecificPart().lastIndexOf(\"!\")); frameworkPath = new File(jarPath).getParentFile().getParentFile().getAbsoluteFile(); } else if (uri.getScheme().equals(\"file\")) { frameworkPath = new File(uri).getParentFile().getParentFile().getParentFile().getParentFile(); } else { throw new UnexpectedException(\"Cannot find the Play! framework - trying with uri: \" + uri + \" scheme \" + uri.getScheme()); } } } catch (Exception e) { throw new UnexpectedException(\"Where is the framework ?\", e); } } 读取配置文件 首先要说明一下，我们这里讨论的是在Play类初始化过程中的读取配置文件过程，为什么要指出这一点呢，因为配置文件读取后会调用插件的onConfigurationRead方法，而在初始化过程中，配置文件是优先于插件加载的，所以在初始化过程中插件的方法并不会生效。等到Play调用start方法启动服务器时，会重新读取配置文件，那时候插件列表已经更新完毕，会执行onConfigurationRead方法。 配置文件的读取和启动脚本中的解析方式基本一样，步骤就是下面几步：\n读取application.conf，将其中的项全部加入Properties 将所有配置项用正则过滤找出真实配置名，并找出所用id的配置项替换 将配置项中的${..}替换为对应值 读取@include引用的配置 我们来看下play对${..}替换过程\nPattern pattern = Pattern.compile(\"\\\\$\\\\{([^}]+)}\"); for (Object key : propsFromFile.keySet()) { String value = propsFromFile.getProperty(key.toString()); Matcher matcher = pattern.matcher(value); StringBuffer newValue = new StringBuffer(100); while (matcher.find()) { String jp = matcher.group(1); String r; //重点是下面这个判断 if (jp.equals(\"application.path\")) { r = Play.applicationPath.getAbsolutePath(); } else if (jp.equals(\"play.path\")) { r = Play.frameworkPath.getAbsolutePath(); } else { r = System.getProperty(jp); if (r == null) { r = System.getenv(jp); } if (r == null) { Logger.warn(\"Cannot replace %s in configuration (%s=%s)\", jp, key, value); continue; } } matcher.appendReplacement(newValue, r.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")); } matcher.appendTail(newValue); propsFromFile.setProperty(key.toString(), newValue.toString()); } 可以看出除了${application.path}和${play.path}，我们还可以通过使用参数和修改环境变量来添加可替换的值\n初始化日志 Play的日志处理放在Logger类中，默认使用log4j作为日志记录工具，初始化过程的顺序如下\n查找配置文件中是否有日志配置文件路径，存在跳至4 查找是否有log4j.xml，存在跳至4 查找是否有log4j.properties，存在跳至4 根据文件后缀使用对应的日志配置解析器 如果是测试模式则加上写入测试结果文件的Appender public static void init() { //查找日志配置文件路径，没有则用log4j.xml String log4jPath = Play.configuration.getProperty(\"application.log.path\", \"/log4j.xml\"); URL log4jConf = Logger.class.getResource(log4jPath); boolean isXMLConfig = log4jPath.endsWith(\".xml\"); //日志配置不存在，查找log4j.properties if (log4jConf == null) { // try again with the .properties isXMLConfig = false; log4jPath = Play.configuration.getProperty(\"application.log.path\", \"/log4j.properties\"); log4jConf = Logger.class.getResource(log4jPath); } //找不到配置文件就关闭日志 if (log4jConf == null) { Properties shutUp = new Properties(); shutUp.setProperty(\"log4j.rootLogger\", \"OFF\"); PropertyConfigurator.configure(shutUp); } else if (Logger.log4j == null) { //判断日志配置文件是否在应用目录下，加这条是因为play软件包目录下有默认的日志配置文件 if (log4jConf.getFile().indexOf(Play.applicationPath.getAbsolutePath()) == 0) { // The log4j configuration file is located somewhere in the application folder, // so it's probably a custom configuration file configuredManually = true; } //根据不同的类型解析 if (isXMLConfig) { DOMConfigurator.configure(log4jConf); } else { PropertyConfigurator.configure(log4jConf); } Logger.log4j = org.apache.log4j.Logger.getLogger(\"play\"); // 测试模式下，将日志追加到test-result/application.log if (Play.runingInTestMode()) { org.apache.log4j.Logger rootLogger = org.apache.log4j.Logger.getRootLogger(); try { if (!Play.getFile(\"test-result\").exists()) { Play.getFile(\"test-result\").mkdir(); } Appender testLog = new FileAppender(new PatternLayout(\"%d{DATE} %-5p ~ %m%n\"), Play.getFile(\"test-result/application.log\").getAbsolutePath(), false); rootLogger.addAppender(testLog); } catch (Exception e) { e.printStackTrace(); } } } } 初始化的代码可以看出log4j.xml的优先级高于log4j.properties，这里可以发现一个问题，Play的日志初始化完全是针对log4j来进行的，但是翻看Logger类的代码可以看到，所有的日志输出方法都会先判断是否使用java.util.logging.Logger来输出日志，在Logger类中也有一个forceJuli字段来判断是否使用，但是这个字段一直没有使用过，也就是说只要不手动改，那forceJuli一直是false。 如果没有做任何配置，那么直接使用Logger来输出日志，那么显示的类名就只会是Play，需要在配置文件中加入application.log.recordCaller=true来将日志输出时显示的类变为调用类名\n查找文件路径 Play类中记录的路径有5种，分别为根目录路径，java文件路径，模板文件路径，主路由路径，模块路由路径。文件路径的添加很简单，就是将文件路径记录在对应的变量中，这里要提的一点是，conf文件夹是被加入到java文件路径中的，所以写在conf文件夹中的java源码也是可以使用的。当然，在conf文件夹里写源码大概会被骂死\n加载模块 Play通过调用loadModules()来加载所有模块，使用的模块在3个地方查找，1是系统环境变量，环境变量MODULES记录的模块将加载，2是配置文件中记录的模块，配置信息为module.开头的模块被加载，3是应用目录下的modules文件夹下的模块被加载。在查找完毕后，会判断是否使用测试模式，是则加入_testrunner模块，并判断是否为dev模式，是则会加入_docviewer模块。 这里我们来看下Play将模块文件加入应用是如何做的\npublic static void addModule(String name, File path) { VirtualFile root = VirtualFile.open(path); modules.put(name, root); if (root.child(\"app\").exists()) { javaPath.add(root.child(\"app\")); } if (root.child(\"app/views\").exists()) { templatesPath.add(root.child(\"app/views\")); } if (root.child(\"conf/routes\").exists()) { modulesRoutes.put(name, root.child(\"conf/routes\")); } roots.add(root); if (!name.startsWith(\"_\")) { Logger.info(\"Module %s is available (%s)\", name, path.getAbsolutePath()); } } 可以看出引入模块其实就是在各个路径下加入模块路径\n加载插件 插件(plugins)是Play framework框架非常重要的组成部分，插件作用于Play运行时的方方面面，包括请求前后的处理，更新字节码等等，具体的插件使用说明我们放在之后的插件篇再说，这里就说说加载插件的过程。 插件的加载过程如下：\n查找java文件路径下存在的play.plugins文件 读取每一个play.plugins，play.plugins中的记录由2部分组成，一个是插件优先级，一个是类名，逐行读取后根据优先级和类目组成LoadingPluginInfo，并加入List 根据优先级对List排序 根据排序完后的列表依次将插件加入至所有插件列表 初始化插件 更新插件列表 我们先来看看将插件加入所有插件列表的过程\nprotected boolean addPlugin( PlayPlugin plugin ){ synchronized( lock ){ //判断插件列表是否存在插件 if( !allPlugins.contains(plugin) ){ allPlugins.add( plugin ); //根据优先级排序 Collections.sort(allPlugins); //创建只读的插件列表 allPlugins_readOnlyCopy = createReadonlyCopy( allPlugins); //启用插件 enablePlugin(plugin); return true; } } return false; } 这是启用插件的方法\npublic boolean enablePlugin( PlayPlugin plugin ){ synchronized( lock ){ //检查是否存在插件 if( allPlugins.contains( plugin )){ //检查插件是否已在启动列表 if( !enabledPlugins.contains( plugin )){ //加入启动插件 enabledPlugins.add( plugin ); //排序 Collections.sort( enabledPlugins); //创建只读列表 enabledPlugins_readOnlyCopy = createReadonlyCopy( enabledPlugins); //更新插件列表 updatePlayPluginsList(); Logger.trace(\"Plugin \" + plugin + \" enabled\"); return true; } } } return false; } 这里有一个问题是，既然加入插件列表时会进行排序，那对List的排序是否就不需要了呢，其实不是的，因为在加入插件列表时会反射生成PlayPlugin的一个实例，如果实例的静态代码段对插件进行了修改，就会出现问题。 在插件加入完毕后，会循环列表进行插件的初始化\nfor( PlayPlugin plugin : getEnabledPlugins()){ if( isEnabled(plugin)){ initializePlugin(plugin); } } 这里为什么要在循环里再判断一遍插件是否启用呢，是为了让高优先级插件可以禁用低优先级插件。\n预编译 预编译是为了在prod模式下加快加载速度，预编译方法的作用是将已经预编译好的文件读入或对文件进行预编译，对文件预编译包括了java文件的预编译以及模板文件的预编译，我们分别来看看\njava预编译 在细说java预编译过程之前，我觉得有必要先来说一下play framework的类加载机制。\nplay.classloading.ApplicationClassloader是play框架的类加载器，所有play框架的代码均由ApplicationClassloader来加载。使用自建的类加载器主要是为了便于处理预编译后的字节码以及方便在dev模式下进行即时的热更新。\nplay.classloading.ApplicationClasses类是应用代码的容器，里面存放了所有的class。\nApplicationClassloader调用通过查找ApplicationClasses来获取对应的类代码（具体来说没有这么简单，因为这边只谈预编译，所以具体的流程暂且不谈，在之后的classloader篇再细说）\njava预编译的入口在ApplicationClassloader.getAllClasses();它的过程如下：\n检查插件是否有编译源码的方法，若有跳至4 扫描之前设定的javaPath下存在的java文件，读取类名，创建ApplicationClass，ApplicationClass类内有类名、java文件、java代码、编译后字节码、增强后字节码等字段，ApplicationClasses中存放的就是一个个ApplicationClass 使用eclipse JDT对源码进行编译，编译后的字节码存到对应的ApplicationClass中 遍历ApplicationClasses中的所有ApplicationClass，判断其是否需要增强，需要增强的类用插件进行增强并写入文件 play的编译器使用的是play.classloading.ApplicationCompiler类，这里对编译过程就不做更多的阐述。 这里有几点值得提一下\n上面步骤2中扫描java文件只根据java文件名来判断类名，也就是说在步骤2的时候，ApplicationClasses容器中存放的class还只是单纯的外部类，而内部类与匿名内部类还不包括在内，在步骤3使用jdt编译时，ApplicationCompiler类会将匿名类与内部类都加到ApplicationClasses容器中，所以在第4步遍历的时候也会将内部类与匿名类的字节码文件增强然后加到文件中 由于步骤1会检查是否有插件会编译源码，也就意味着我们可以通过自写插件来覆盖play原有的编译过程。这点我觉得非常不错，因为在使用play做为工程框架时，等到代码量很大时，每次编译过程都会非常漫长，因为play默认会将所有java文件全部重新编译一遍，而这有时候是很不必要的，因为其实只要重新编译更改的文件即可，针对这一点我写了一个根据文件更改时间选择编译的插件，这个放到之后的play应用中再谈。 下面就是java预编译的主要代码\n//判断是否有插件会进行编译 if(!Play.pluginCollection.compileSources()) { List\u003cApplicationClass\u003e all = new ArrayList\u003cApplicationClass\u003e(); //在javaPath中找所有类 for (VirtualFile virtualFile : Play.javaPath) { all.addAll(getAllClasses(virtualFile)); } List\u003cString\u003e classNames = new ArrayList\u003cString\u003e(); //将所有类名组成list for (int i = 0; i \u003c all.size(); i++) { ApplicationClass applicationClass = all.get(i); if (applicationClass != null \u0026\u0026 !applicationClass.compiled \u0026\u0026 applicationClass.isClass()) { classNames.add(all.get(i).name); } } //调用编译器编译 Play.classes.compiler.compile(classNames.toArray(new String[classNames.size()])); } //遍历所有类，添加至allClasses，即ApplicationClasses容器中 for (ApplicationClass applicationClass : Play.classes.all()) { //loadApplicationClass方法关键代码如下 Class clazz = loadApplicationClass(applicationClass.name); if (clazz != null) { allClasses.add(clazz); } } long start = System.currentTimeMillis(); //从ApplicationClasses容器中找对应的ApplicationClass ApplicationClass applicationClass = Play.classes.getApplicationClass(name); if (applicationClass != null) { //isDefinable方法就是判断applicationClass是否已经编译且存在对应的javaClass if (applicationClass.isDefinable()) { return applicationClass.javaClass; } //查找之前是否存在编译结果 byte[] bc = BytecodeCache.getBytecode(name, applicationClass.javaSource); if (Logger.isTraceEnabled()) { Logger.trace(\"Compiling code for %s\", name); } //判断applicationClass是一个类还是package-info if (!applicationClass.isClass()) { definePackage(applicationClass.getPackage(), null, null, null, null, null, null, null); } else { loadPackage(name); } //如果之前的编译结果存在，就用之前的 if (bc != null) { applicationClass.enhancedByteCode = bc; applicationClass.javaClass = defineClass(applicationClass.name, applicationClass.enhancedByteCode, 0, applicationClass.enhancedByteCode.length, protectionDomain); resolveClass(applicationClass.javaClass); if (!applicationClass.isClass()) { applicationClass.javaPackage = applicationClass.javaClass.getPackage(); } if (Logger.isTraceEnabled()) { Logger.trace(\"%sms to load class %s from cache\", System.currentTimeMillis() - start, name); } return applicationClass.javaClass; } //如果applicationClass编译过了或者编译后有字节码，进行字节码增强 if (applicationClass.javaByteCode != null || applicationClass.compile() != null) { //进行字节码增强 applicationClass.enhance(); applicationClass.javaClass = defineClass(applicationClass.name, applicationClass.enhancedByteCode, 0, applicationClass.enhancedByteCode.length, protectionDomain); BytecodeCache.cacheBytecode(applicationClass.enhancedByteCode, name, applicationClass.javaSource); resolveClass(applicationClass.javaClass); if (!applicationClass.isClass()) { applicationClass.javaPackage = applicationClass.javaClass.getPackage(); } if (Logger.isTraceEnabled()) { Logger.trace(\"%sms to load class %s\", System.currentTimeMillis() - start, name); } return applicationClass.javaClass; } Play.classes.classes.remove(name); } 模板预编译 不同于java的预编译，模板的预编译结果虽然也会存放在precompile文件夹，但是在运行过程中模板并不是一次性全部加载的，模板的加载主要通过play.templates.TemplateLoader来进行，TemplateLoader中存放了使用过的模板信息。 在模板预编译过程中，主要是步骤如下：\n扫描Play.templatesPath目录下所有模板文件 遍历文件，用TemplateLoader.load来加载源文件，并进行模板编译，产生Groovy源码 对编译后的Groovy源码进行编译，并用base64加密写入文件 这里只对模板预编译流程做一个梳理，至于编译的过程放在之后的模板篇再说\nplay framework的启动 从上一篇server与servletWrapper中我们可以发现，play framework并不是一定在脚本启动之后便启动服务器，在我们使用dev模式进行开发时也会发现，play总是需要接受到一个请求后才会有真正的启动流程。我们这一节就来看看play的启动过程是怎么样的，这个启动与server或servletWrapper的启动的区别在于，play启动后便真正开始业务处理，而server与servletWrapper的启动仅仅是启动了监听端口，当然要清楚的是servletWrapper启动时也会自动启动play\npublic static synchronized void start() { try { //如果已经启动了，先停止，这里是为了dev模式的热更新 if (started) { stop(); } //如果不是独立的server，即如果不是放在servlet容器中运行，注册关闭事件 if( standalonePlayServer) { // Can only register shutdown-hook if running as standalone server if (!shutdownHookEnabled) { //registers shutdown hook - Now there's a good chance that we can notify //our plugins that we're going down when some calls ctrl+c or just kills our process.. shutdownHookEnabled = true; Runtime.getRuntime().addShutdownHook(new Thread() { public void run() { Play.stop(); } }); } } //如果是dev模式启动，重新加载所有class和插件 if (mode == Mode.DEV) { // Need a new classloader classloader = new ApplicationClassloader(); // Put it in the current context for any code that relies on having it there Thread.currentThread().setContextClassLoader(classloader); // Reload plugins pluginCollection.reloadApplicationPlugins(); } // 读取配置文件 readConfiguration(); // 配置日志 String logLevel = configuration.getProperty(\"application.log\", \"INFO\"); //only override log-level if Logger was not configured manually if( !Logger.configuredManually) { Logger.setUp(logLevel); } Logger.recordCaller = Boolean.parseBoolean(configuration.getProperty(\"application.log.recordCaller\", \"false\")); // 设置语言 langs = new ArrayList\u003cString\u003e(Arrays.asList(configuration.getProperty(\"application.langs\", \"\").split(\",\"))); if (langs.size() == 1 \u0026\u0026 langs.get(0).trim().length() == 0) { langs = new ArrayList\u003cString\u003e(16); } // 重新加载模板 TemplateLoader.cleanCompiledCache(); // 设置secretKey secretKey = configuration.getProperty(\"application.secret\", \"\").trim(); if (secretKey.length() == 0) { Logger.warn(\"No secret key defined. Sessions will not be encrypted\"); } // 设置默认web encoding String _defaultWebEncoding = configuration.getProperty(\"application.web_encoding\"); if( _defaultWebEncoding != null ) { Logger.info(\"Using custom default web encoding: \" + _defaultWebEncoding); defaultWebEncoding = _defaultWebEncoding; // Must update current response also, since the request/response triggering // this configuration-loading in dev-mode have already been // set up with the previous encoding if( Http.Response.current() != null ) { Http.Response.current().encoding = _defaultWebEncoding; } } // 加载所有class Play.classloader.getAllClasses(); // 加载路由 Router.detectChanges(ctxPath); // 初始化缓存 Cache.init(); // 运行插件onApplicationStart方法 try { pluginCollection.onApplicationStart(); } catch (Exception e) { if (Play.mode.isProd()) { Logger.error(e, \"Can't start in PROD mode with errors\"); } if (e instanceof RuntimeException) { throw (RuntimeException) e; } throw new UnexpectedException(e); } if (firstStart) { Logger.info(\"Application '%s' is now started !\", configuration.getProperty(\"application.name\", \"\")); firstStart = false; } // We made it started = true; startedAt = System.currentTimeMillis(); // 运行插件afterApplicationStart方法 pluginCollection.afterApplicationStart(); } catch (PlayException e) { started = false; try { Cache.stop(); } catch (Exception ignored) {} throw e; } catch (Exception e) { started = false; try { Cache.stop(); } catch (Exception ignored) {} throw new UnexpectedException(e); } } 可以看出play的启动和play的初始化有很多相同的地方，包括加载配置，加载日志等，启动过程有很多有意思的地方\nplay的启动不会重置模块列表，也就是说如果在dev模式下对配置文件进行修改增加了模块必须要重启服务器，热更新是无效的。 在play的初始化过程中，如果是使用容器打开服务器时就会加载预编译文件，这时候已经读取一遍预编译源码了，所有在启动过程中的getAllClasses就不会再去查找了 插件的onApplicationStart方法一般就是执行些插件初始化的工作，所以遇到错误就会中断启动过程，而afterApplicationStart是在启动完成后在运行的，很有意思的是，用@OnApplicationStart标识的job类是在afterApplicationStart阶段运行的，而不是onApplicationStart阶段。那为什么要叫这个名字 可以看出路由的解析是在play的启动过程中进行的，具体过程就是读取路径下的路由文件，然后路由的具体解析过程放在模板篇一起讲吧\n总结 Play类的初始化与启动已经说的差不多了，下一篇我们来看下ActionInvoker与mvc\n","wordCount":"1547","inLanguage":"en","image":"https://example.org/avatar.png","datePublished":"2018-01-20T15:52:41Z","dateModified":"2018-01-20T15:52:41Z","author":{"@type":"Person","name":"asuka"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://example.org/posts/play-framework/part3play%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8/"},"publisher":{"@type":"Organization","name":"404 NOT FOUND","logo":{"@type":"ImageObject","url":"https://example.org/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://example.org/ accesskey=h title="404 NOT FOUND (Alt + H)">404 NOT FOUND</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://example.org/posts/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://example.org/>Home</a>&nbsp;»&nbsp;<a href=https://example.org/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Play framework源码解析 Part3:Play的初始化与启动</h1><div class=post-meta><span title='2018-01-20 15:52:41 +0000 UTC'>January 20, 2018</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1547 words&nbsp;·&nbsp;asuka</div></header><div class=post-content><p>在上一篇中，我们分析了play的2种启动方式，这一篇，我们来看看Play类的初始化过程</p><h1 id=play类>Play类<a hidden class=anchor aria-hidden=true href=#play类>#</a></h1><p>无论是Server还是ServletWrapper方式运行，在他们的入口中都会运行Play.init()来对Play类进行初始化。那在解析初始化之前，我们先来看看Play类是做什么的，它里面有什么重要的方法。
首先要明确的一点是，Play类是整个Play framework框架的管理、配置中心，它存放了大部分框架需要的成员变量，例如id,配置信息,所有加载的class,使用的插件管理器等等。下图就是Play类中的方法列表。
<img alt=Play类的方法列表 loading=lazy src=https://s1.ax1x.com/2018/02/01/9FqoHU.png>
这其中加注释的几个方法是比较重要的，我们下面便来从init开始一点点剖析Play类中的各个方法。</p><h1 id=play的初始化>Play的初始化<a hidden class=anchor aria-hidden=true href=#play的初始化>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>(File root, String id) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Simple things</span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> id;
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>started</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>applicationPath</span> <span style=color:#f92672>=</span> root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载所有 play.static 中的记录的类</span>
</span></span><span style=display:flex><span>    initStaticStuff();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//猜测play framework的路径</span>
</span></span><span style=display:flex><span>    guessFrameworkPath();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 读取配置文件</span>
</span></span><span style=display:flex><span>    readConfiguration();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>classes</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ApplicationClasses();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化日志</span>
</span></span><span style=display:flex><span>    Logger.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    String logLevel <span style=color:#f92672>=</span> configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.log&#34;</span>, <span style=color:#e6db74>&#34;INFO&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//only override log-level if Logger was not configured manually</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>( <span style=color:#f92672>!</span>Logger.<span style=color:#a6e22e>configuredManually</span>) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>setUp</span>(logLevel);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Logger.<span style=color:#a6e22e>recordCaller</span> <span style=color:#f92672>=</span> Boolean.<span style=color:#a6e22e>parseBoolean</span>(configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.log.recordCaller&#34;</span>, <span style=color:#e6db74>&#34;false&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Starting %s&#34;</span>, root.<span style=color:#a6e22e>getAbsolutePath</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>//设置临时文件夹</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;play.tmp&#34;</span>, <span style=color:#e6db74>&#34;tmp&#34;</span>).<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;none&#34;</span>)) {
</span></span><span style=display:flex><span>        tmpDir <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;No tmp folder will be used (play.tmp is set to none)&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        tmpDir <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;play.tmp&#34;</span>, <span style=color:#e6db74>&#34;tmp&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tmpDir.<span style=color:#a6e22e>isAbsolute</span>()) {
</span></span><span style=display:flex><span>            tmpDir <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(applicationPath, tmpDir.<span style=color:#a6e22e>getPath</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;Using %s as tmp dir&#34;</span>, Play.<span style=color:#a6e22e>tmpDir</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tmpDir.<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (readOnlyTmp) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;ReadOnly tmp&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                tmpDir.<span style=color:#a6e22e>mkdirs</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>                tmpDir <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                Logger.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;No tmp folder will be used (cannot create the tmp dir)&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置运行模式</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        mode <span style=color:#f92672>=</span> Mode.<span style=color:#a6e22e>valueOf</span>(configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.mode&#34;</span>, <span style=color:#e6db74>&#34;DEV&#34;</span>).<span style=color:#a6e22e>toUpperCase</span>());
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (IllegalArgumentException e) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Illegal mode &#39;%s&#39;, use either prod or dev&#34;</span>, configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.mode&#34;</span>));
</span></span><span style=display:flex><span>        fatalServerErrorOccurred();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (usePrecompiled <span style=color:#f92672>||</span> forceProd) {
</span></span><span style=display:flex><span>        mode <span style=color:#f92672>=</span> Mode.<span style=color:#a6e22e>PROD</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取http使用路径</span>
</span></span><span style=display:flex><span>    ctxPath <span style=color:#f92672>=</span> configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;http.path&#34;</span>, ctxPath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置文件路径</span>
</span></span><span style=display:flex><span>    VirtualFile appRoot <span style=color:#f92672>=</span> VirtualFile.<span style=color:#a6e22e>open</span>(applicationPath);
</span></span><span style=display:flex><span>    roots.<span style=color:#a6e22e>add</span>(appRoot);
</span></span><span style=display:flex><span>    javaPath <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CopyOnWriteArrayList<span style=color:#f92672>&lt;</span>VirtualFile<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    javaPath.<span style=color:#a6e22e>add</span>(appRoot.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;app&#34;</span>));
</span></span><span style=display:flex><span>    javaPath.<span style=color:#a6e22e>add</span>(appRoot.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;conf&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置模板路径</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (appRoot.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;app/views&#34;</span>).<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>        templatesPath <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>VirtualFile<span style=color:#f92672>&gt;</span>(2);
</span></span><span style=display:flex><span>        templatesPath.<span style=color:#a6e22e>add</span>(appRoot.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;app/views&#34;</span>));
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        templatesPath <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>VirtualFile<span style=color:#f92672>&gt;</span>(1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置路由文件</span>
</span></span><span style=display:flex><span>    routes <span style=color:#f92672>=</span> appRoot.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;conf/routes&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置模块路径</span>
</span></span><span style=display:flex><span>    modulesRoutes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;</span>String, VirtualFile<span style=color:#f92672>&gt;</span>(16);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载模块</span>
</span></span><span style=display:flex><span>    loadModules();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 模板路径中加入框架自带的模板文件</span>
</span></span><span style=display:flex><span>    templatesPath.<span style=color:#a6e22e>add</span>(VirtualFile.<span style=color:#a6e22e>open</span>(<span style=color:#66d9ef>new</span> File(frameworkPath, <span style=color:#e6db74>&#34;framework/templates&#34;</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化classloader</span>
</span></span><span style=display:flex><span>    classloader <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ApplicationClassloader();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fix ctxPath</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;/&#34;</span>.<span style=color:#a6e22e>equals</span>(Play.<span style=color:#a6e22e>ctxPath</span>)) {
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>ctxPath</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置cookie域名</span>
</span></span><span style=display:flex><span>    Http.<span style=color:#a6e22e>Cookie</span>.<span style=color:#a6e22e>defaultDomain</span> <span style=color:#f92672>=</span> configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.defaultCookieDomain&#34;</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Http.<span style=color:#a6e22e>Cookie</span>.<span style=color:#a6e22e>defaultDomain</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Using default cookie domain: &#34;</span> <span style=color:#f92672>+</span> Http.<span style=color:#a6e22e>Cookie</span>.<span style=color:#a6e22e>defaultDomain</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载插件</span>
</span></span><span style=display:flex><span>    pluginCollection.<span style=color:#a6e22e>loadPlugins</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是prod直接启动</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (mode <span style=color:#f92672>==</span> Mode.<span style=color:#a6e22e>PROD</span> <span style=color:#f92672>||</span> System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;precompile&#34;</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        mode <span style=color:#f92672>=</span> Mode.<span style=color:#a6e22e>PROD</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//预编译</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (preCompile() <span style=color:#f92672>&amp;&amp;</span> System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;precompile&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            start();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;You&#39;re running Play! in DEV mode&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pluginCollection.<span style=color:#a6e22e>onApplicationReady</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>initialized</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上面的代码所示，初始化过程主要的顺序为：</p><ol><li>加载所有play.static中记录的类</li><li>获取框架路径</li><li>读取配置文件</li><li>初始化日志</li><li>获取java文件、模板文件路径</li><li>加载模块</li><li>加载插件</li><li>若为prod模式进行预编译</li></ol><p>我们来依次看看Play在这些过程中做了什么事情。</p><h2 id=加载playstatic>加载play.static<a hidden class=anchor aria-hidden=true href=#加载playstatic>#</a></h2><p>Play在初始化过程中会调用initStaticStuff()方法来检查代码目录下是否存在play.static文件，如果存在，那么就逐行读取文件中记录的类，并通过反射加载类中的静态初始化代码段。至于作用吗，不知道有什么用，这段代码的优先级太高了，早于初始化过程运行，若在初始化过程结束后运行还可以用来覆写Play类中的配置信息。<del>或者自己写插件然后在play.static中初始化插件依赖？或者绑定新的数据源？</del></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initStaticStuff</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Play! plugings</span>
</span></span><span style=display:flex><span>    Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> urls <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        urls <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getClassLoader</span>().<span style=color:#a6e22e>getResources</span>(<span style=color:#e6db74>&#34;play.static&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (urls <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> urls.<span style=color:#a6e22e>hasMoreElements</span>()) {
</span></span><span style=display:flex><span>        URL url <span style=color:#f92672>=</span> urls.<span style=color:#a6e22e>nextElement</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            BufferedReader reader <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedReader(<span style=color:#66d9ef>new</span> InputStreamReader(url.<span style=color:#a6e22e>openStream</span>(), <span style=color:#e6db74>&#34;utf-8&#34;</span>));
</span></span><span style=display:flex><span>            String line <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> ((line <span style=color:#f92672>=</span> reader.<span style=color:#a6e22e>readLine</span>()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    Class.<span style=color:#a6e22e>forName</span>(line);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                    Logger.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;! Cannot init static: &#34;</span> <span style=color:#f92672>+</span> line);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>error</span>(ex, <span style=color:#e6db74>&#34;Cannot load %s&#34;</span>, url);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=获取框架路径>获取框架路径<a hidden class=anchor aria-hidden=true href=#获取框架路径>#</a></h2><p>获取框架路径很简单，就是判断是用jar模式运行还是直接用文件运行，然后读取对应的路径</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>guessFrameworkPath</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Guess the framework path</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        URL versionUrl <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getResource</span>(<span style=color:#e6db74>&#34;/play/version&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Read the content of the file</span>
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>version</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LineNumberReader(<span style=color:#66d9ef>new</span> InputStreamReader(versionUrl.<span style=color:#a6e22e>openStream</span>())).<span style=color:#a6e22e>readLine</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This is used only by the embedded server (Mina, Netty, Jetty etc)</span>
</span></span><span style=display:flex><span>        URI uri <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> URI(versionUrl.<span style=color:#a6e22e>toString</span>().<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34; &#34;</span>, <span style=color:#e6db74>&#34;%20&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (frameworkPath <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>frameworkPath.<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (uri.<span style=color:#a6e22e>getScheme</span>().<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;jar&#34;</span>)) {
</span></span><span style=display:flex><span>                String jarPath <span style=color:#f92672>=</span> uri.<span style=color:#a6e22e>getSchemeSpecificPart</span>().<span style=color:#a6e22e>substring</span>(5, uri.<span style=color:#a6e22e>getSchemeSpecificPart</span>().<span style=color:#a6e22e>lastIndexOf</span>(<span style=color:#e6db74>&#34;!&#34;</span>));
</span></span><span style=display:flex><span>                frameworkPath <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(jarPath).<span style=color:#a6e22e>getParentFile</span>().<span style=color:#a6e22e>getParentFile</span>().<span style=color:#a6e22e>getAbsoluteFile</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (uri.<span style=color:#a6e22e>getScheme</span>().<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;file&#34;</span>)) {
</span></span><span style=display:flex><span>                frameworkPath <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(uri).<span style=color:#a6e22e>getParentFile</span>().<span style=color:#a6e22e>getParentFile</span>().<span style=color:#a6e22e>getParentFile</span>().<span style=color:#a6e22e>getParentFile</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(<span style=color:#e6db74>&#34;Cannot find the Play! framework - trying with uri: &#34;</span> <span style=color:#f92672>+</span> uri <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; scheme &#34;</span> <span style=color:#f92672>+</span> uri.<span style=color:#a6e22e>getScheme</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(<span style=color:#e6db74>&#34;Where is the framework ?&#34;</span>, e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=读取配置文件>读取配置文件<a hidden class=anchor aria-hidden=true href=#读取配置文件>#</a></h2><p>首先要说明一下，我们这里讨论的是在Play类初始化过程中的读取配置文件过程，为什么要指出这一点呢，因为配置文件读取后会调用插件的onConfigurationRead方法，而在初始化过程中，配置文件是优先于插件加载的，所以在初始化过程中插件的方法并不会生效。等到Play调用start方法启动服务器时，会重新读取配置文件，那时候插件列表已经更新完毕，会执行onConfigurationRead方法。
配置文件的读取和启动脚本中的解析方式基本一样，步骤就是下面几步：</p><ol><li>读取application.conf，将其中的项全部加入Properties</li><li>将所有配置项用正则过滤找出真实配置名，并找出所用id的配置项替换</li><li>将配置项中的${..}替换为对应值</li><li>读取@include引用的配置</li></ol><p>我们来看下play对${..}替换过程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Pattern pattern <span style=color:#f92672>=</span> Pattern.<span style=color:#a6e22e>compile</span>(<span style=color:#e6db74>&#34;\\$\\{([^}]+)}&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (Object key : propsFromFile.<span style=color:#a6e22e>keySet</span>()) {
</span></span><span style=display:flex><span>    String value <span style=color:#f92672>=</span> propsFromFile.<span style=color:#a6e22e>getProperty</span>(key.<span style=color:#a6e22e>toString</span>());
</span></span><span style=display:flex><span>    Matcher matcher <span style=color:#f92672>=</span> pattern.<span style=color:#a6e22e>matcher</span>(value);
</span></span><span style=display:flex><span>    StringBuffer newValue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuffer(100);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (matcher.<span style=color:#a6e22e>find</span>()) {
</span></span><span style=display:flex><span>        String jp <span style=color:#f92672>=</span> matcher.<span style=color:#a6e22e>group</span>(1);
</span></span><span style=display:flex><span>        String r;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//重点是下面这个判断</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (jp.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;application.path&#34;</span>)) {
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>applicationPath</span>.<span style=color:#a6e22e>getAbsolutePath</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (jp.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;play.path&#34;</span>)) {
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>frameworkPath</span>.<span style=color:#a6e22e>getAbsolutePath</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>getProperty</span>(jp);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                r <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>getenv</span>(jp);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                Logger.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;Cannot replace %s in configuration (%s=%s)&#34;</span>, jp, key, value);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        matcher.<span style=color:#a6e22e>appendReplacement</span>(newValue, r.<span style=color:#a6e22e>replaceAll</span>(<span style=color:#e6db74>&#34;\\\\&#34;</span>, <span style=color:#e6db74>&#34;\\\\\\\\&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    matcher.<span style=color:#a6e22e>appendTail</span>(newValue);
</span></span><span style=display:flex><span>    propsFromFile.<span style=color:#a6e22e>setProperty</span>(key.<span style=color:#a6e22e>toString</span>(), newValue.<span style=color:#a6e22e>toString</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看出除了${application.path}和${play.path}，我们还可以通过使用参数和修改环境变量来添加可替换的值</p><h2 id=初始化日志>初始化日志<a hidden class=anchor aria-hidden=true href=#初始化日志>#</a></h2><p>Play的日志处理放在Logger类中，默认使用log4j作为日志记录工具，初始化过程的顺序如下</p><ol><li>查找配置文件中是否有日志配置文件路径，存在跳至4</li><li>查找是否有log4j.xml，存在跳至4</li><li>查找是否有log4j.properties，存在跳至4</li><li>根据文件后缀使用对应的日志配置解析器</li><li>如果是测试模式则加上写入测试结果文件的Appender</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//查找日志配置文件路径，没有则用log4j.xml</span>
</span></span><span style=display:flex><span>    String log4jPath <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>configuration</span>.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.log.path&#34;</span>, <span style=color:#e6db74>&#34;/log4j.xml&#34;</span>);
</span></span><span style=display:flex><span>    URL log4jConf <span style=color:#f92672>=</span> Logger.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getResource</span>(log4jPath);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> isXMLConfig <span style=color:#f92672>=</span> log4jPath.<span style=color:#a6e22e>endsWith</span>(<span style=color:#e6db74>&#34;.xml&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//日志配置不存在，查找log4j.properties</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (log4jConf <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) { <span style=color:#75715e>// try again with the .properties</span>
</span></span><span style=display:flex><span>        isXMLConfig <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        log4jPath <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>configuration</span>.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.log.path&#34;</span>, <span style=color:#e6db74>&#34;/log4j.properties&#34;</span>);
</span></span><span style=display:flex><span>        log4jConf <span style=color:#f92672>=</span> Logger.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getResource</span>(log4jPath);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//找不到配置文件就关闭日志</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (log4jConf <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        Properties shutUp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Properties();
</span></span><span style=display:flex><span>        shutUp.<span style=color:#a6e22e>setProperty</span>(<span style=color:#e6db74>&#34;log4j.rootLogger&#34;</span>, <span style=color:#e6db74>&#34;OFF&#34;</span>);
</span></span><span style=display:flex><span>        PropertyConfigurator.<span style=color:#a6e22e>configure</span>(shutUp);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>log4j</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//判断日志配置文件是否在应用目录下，加这条是因为play软件包目录下有默认的日志配置文件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (log4jConf.<span style=color:#a6e22e>getFile</span>().<span style=color:#a6e22e>indexOf</span>(Play.<span style=color:#a6e22e>applicationPath</span>.<span style=color:#a6e22e>getAbsolutePath</span>()) <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The log4j configuration file is located somewhere in the application folder,</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// so it&#39;s probably a custom configuration file</span>
</span></span><span style=display:flex><span>            configuredManually <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//根据不同的类型解析</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (isXMLConfig) {
</span></span><span style=display:flex><span>            DOMConfigurator.<span style=color:#a6e22e>configure</span>(log4jConf);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            PropertyConfigurator.<span style=color:#a6e22e>configure</span>(log4jConf);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>log4j</span> <span style=color:#f92672>=</span> org.<span style=color:#a6e22e>apache</span>.<span style=color:#a6e22e>log4j</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>getLogger</span>(<span style=color:#e6db74>&#34;play&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 测试模式下，将日志追加到test-result/application.log</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>runingInTestMode</span>()) {
</span></span><span style=display:flex><span>            org.<span style=color:#a6e22e>apache</span>.<span style=color:#a6e22e>log4j</span>.<span style=color:#a6e22e>Logger</span> rootLogger <span style=color:#f92672>=</span> org.<span style=color:#a6e22e>apache</span>.<span style=color:#a6e22e>log4j</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>getRootLogger</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Play.<span style=color:#a6e22e>getFile</span>(<span style=color:#e6db74>&#34;test-result&#34;</span>).<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>                    Play.<span style=color:#a6e22e>getFile</span>(<span style=color:#e6db74>&#34;test-result&#34;</span>).<span style=color:#a6e22e>mkdir</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Appender testLog <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileAppender(<span style=color:#66d9ef>new</span> PatternLayout(<span style=color:#e6db74>&#34;%d{DATE} %-5p ~ %m%n&#34;</span>), Play.<span style=color:#a6e22e>getFile</span>(<span style=color:#e6db74>&#34;test-result/application.log&#34;</span>).<span style=color:#a6e22e>getAbsolutePath</span>(), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                rootLogger.<span style=color:#a6e22e>addAppender</span>(testLog);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>初始化的代码可以看出log4j.xml的优先级高于log4j.properties，这里可以发现一个问题，Play的日志初始化完全是针对log4j来进行的，但是翻看Logger类的代码可以看到，所有的日志输出方法都会先判断是否使用java.util.logging.Logger来输出日志，在Logger类中也有一个forceJuli字段来判断是否使用，但是这个字段一直没有使用过，也就是说只要不手动改，那forceJuli一直是false。
如果没有做任何配置，那么直接使用Logger来输出日志，那么显示的类名就只会是Play，需要在配置文件中加入application.log.recordCaller=true来将日志输出时显示的类变为调用类名</p><h2 id=查找文件路径>查找文件路径<a hidden class=anchor aria-hidden=true href=#查找文件路径>#</a></h2><p>Play类中记录的路径有5种，分别为根目录路径，java文件路径，模板文件路径，主路由路径，模块路由路径。文件路径的添加很简单，就是将文件路径记录在对应的变量中，这里要提的一点是，conf文件夹是被加入到java文件路径中的，所以写在conf文件夹中的java源码也是可以使用的。<del>当然，在conf文件夹里写源码大概会被骂死</del></p><h2 id=加载模块>加载模块<a hidden class=anchor aria-hidden=true href=#加载模块>#</a></h2><p>Play通过调用loadModules()来加载所有模块，使用的模块在3个地方查找，1是系统环境变量，环境变量MODULES记录的模块将加载，2是配置文件中记录的模块，配置信息为module.开头的模块被加载，3是应用目录下的modules文件夹下的模块被加载。在查找完毕后，会判断是否使用测试模式，是则加入_testrunner模块，并判断是否为dev模式，是则会加入_docviewer模块。
这里我们来看下Play将模块文件加入应用是如何做的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addModule</span>(String name, File path) {
</span></span><span style=display:flex><span>    VirtualFile root <span style=color:#f92672>=</span> VirtualFile.<span style=color:#a6e22e>open</span>(path);
</span></span><span style=display:flex><span>    modules.<span style=color:#a6e22e>put</span>(name, root);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (root.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;app&#34;</span>).<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>        javaPath.<span style=color:#a6e22e>add</span>(root.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;app&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (root.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;app/views&#34;</span>).<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>        templatesPath.<span style=color:#a6e22e>add</span>(root.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;app/views&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (root.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;conf/routes&#34;</span>).<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>        modulesRoutes.<span style=color:#a6e22e>put</span>(name, root.<span style=color:#a6e22e>child</span>(<span style=color:#e6db74>&#34;conf/routes&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    roots.<span style=color:#a6e22e>add</span>(root);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>name.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#34;_&#34;</span>)) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Module %s is available (%s)&#34;</span>, name, path.<span style=color:#a6e22e>getAbsolutePath</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看出引入模块其实就是在各个路径下加入模块路径</p><h2 id=加载插件>加载插件<a hidden class=anchor aria-hidden=true href=#加载插件>#</a></h2><p>插件(plugins)是Play framework框架非常重要的组成部分，插件作用于Play运行时的方方面面，包括请求前后的处理，更新字节码等等，具体的插件使用说明我们放在之后的插件篇再说，这里就说说加载插件的过程。
插件的加载过程如下：</p><ol><li>查找java文件路径下存在的play.plugins文件</li><li>读取每一个play.plugins，play.plugins中的记录由2部分组成，一个是插件优先级，一个是类名，逐行读取后根据优先级和类目组成LoadingPluginInfo，并加入List<loadingplugininfo></li><li>根据优先级对List<loadingplugininfo>排序</li><li>根据排序完后的列表依次将插件加入至所有插件列表</li><li>初始化插件</li><li>更新插件列表</li></ol><p>我们先来看看将插件加入所有插件列表的过程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>addPlugin</span>( PlayPlugin plugin ){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span>( lock ){
</span></span><span style=display:flex><span>        <span style=color:#75715e>//判断插件列表是否存在插件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( <span style=color:#f92672>!</span>allPlugins.<span style=color:#a6e22e>contains</span>(plugin) ){
</span></span><span style=display:flex><span>            allPlugins.<span style=color:#a6e22e>add</span>( plugin );
</span></span><span style=display:flex><span>            <span style=color:#75715e>//根据优先级排序</span>
</span></span><span style=display:flex><span>            Collections.<span style=color:#a6e22e>sort</span>(allPlugins);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//创建只读的插件列表</span>
</span></span><span style=display:flex><span>            allPlugins_readOnlyCopy <span style=color:#f92672>=</span> createReadonlyCopy( allPlugins);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//启用插件</span>
</span></span><span style=display:flex><span>            enablePlugin(plugin);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是启用插件的方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>enablePlugin</span>( PlayPlugin plugin ){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span>( lock ){
</span></span><span style=display:flex><span>        <span style=color:#75715e>//检查是否存在插件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( allPlugins.<span style=color:#a6e22e>contains</span>( plugin )){
</span></span><span style=display:flex><span>            <span style=color:#75715e>//检查插件是否已在启动列表</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>( <span style=color:#f92672>!</span>enabledPlugins.<span style=color:#a6e22e>contains</span>( plugin )){
</span></span><span style=display:flex><span>                <span style=color:#75715e>//加入启动插件</span>
</span></span><span style=display:flex><span>                enabledPlugins.<span style=color:#a6e22e>add</span>( plugin );
</span></span><span style=display:flex><span>                <span style=color:#75715e>//排序</span>
</span></span><span style=display:flex><span>                Collections.<span style=color:#a6e22e>sort</span>( enabledPlugins);
</span></span><span style=display:flex><span>                <span style=color:#75715e>//创建只读列表</span>
</span></span><span style=display:flex><span>                enabledPlugins_readOnlyCopy <span style=color:#f92672>=</span> createReadonlyCopy( enabledPlugins);
</span></span><span style=display:flex><span>                <span style=color:#75715e>//更新插件列表</span>
</span></span><span style=display:flex><span>                updatePlayPluginsList();
</span></span><span style=display:flex><span>                Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;Plugin &#34;</span> <span style=color:#f92672>+</span> plugin <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; enabled&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里有一个问题是，既然加入插件列表时会进行排序，那对List<loadingplugininfo>的排序是否就不需要了呢，其实不是的，因为在加入插件列表时会反射生成PlayPlugin的一个实例，如果实例的静态代码段对插件进行了修改，就会出现问题。
在插件加入完毕后，会循环列表进行插件的初始化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span>( PlayPlugin plugin : getEnabledPlugins()){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>( isEnabled(plugin)){
</span></span><span style=display:flex><span>        initializePlugin(plugin);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里为什么要在循环里再判断一遍插件是否启用呢，是为了让高优先级插件可以禁用低优先级插件。</p><h2 id=预编译>预编译<a hidden class=anchor aria-hidden=true href=#预编译>#</a></h2><p>预编译是为了在prod模式下加快加载速度，预编译方法的作用是将已经预编译好的文件读入或对文件进行预编译，对文件预编译包括了java文件的预编译以及模板文件的预编译，我们分别来看看</p><h3 id=java预编译>java预编译<a hidden class=anchor aria-hidden=true href=#java预编译>#</a></h3><p>在细说java预编译过程之前，我觉得有必要先来说一下play framework的类加载机制。<br>play.classloading.ApplicationClassloader是play框架的类加载器，所有play框架的代码均由ApplicationClassloader来加载。使用自建的类加载器主要是为了便于处理预编译后的字节码以及方便在dev模式下进行即时的热更新。<br>play.classloading.ApplicationClasses类是应用代码的容器，里面存放了所有的class。<br>ApplicationClassloader调用通过查找ApplicationClasses来获取对应的类代码（具体来说没有这么简单，因为这边只谈预编译，所以具体的流程暂且不谈，在之后的classloader篇再细说）<br>java预编译的入口在ApplicationClassloader.getAllClasses();它的过程如下：</p><ol><li>检查插件是否有编译源码的方法，若有跳至4</li><li>扫描之前设定的javaPath下存在的java文件，读取类名，创建ApplicationClass，ApplicationClass类内有类名、java文件、java代码、编译后字节码、增强后字节码等字段，ApplicationClasses中存放的就是一个个ApplicationClass</li><li>使用eclipse JDT对源码进行编译，编译后的字节码存到对应的ApplicationClass中</li><li>遍历ApplicationClasses中的所有ApplicationClass，判断其是否需要增强，需要增强的类用插件进行增强并写入文件</li></ol><p>play的编译器使用的是play.classloading.ApplicationCompiler类，这里对编译过程就不做更多的阐述。
这里有几点值得提一下</p><ol><li>上面步骤2中扫描java文件只根据java文件名来判断类名，也就是说在步骤2的时候，ApplicationClasses容器中存放的class还只是单纯的外部类，而内部类与匿名内部类还不包括在内，在步骤3使用jdt编译时，ApplicationCompiler类会将匿名类与内部类都加到ApplicationClasses容器中，所以在第4步遍历的时候也会将内部类与匿名类的字节码文件增强然后加到文件中</li><li>由于步骤1会检查是否有插件会编译源码，也就意味着我们可以通过自写插件来覆盖play原有的编译过程。这点我觉得非常不错，因为在使用play做为工程框架时，等到代码量很大时，每次编译过程都会非常漫长，因为play默认会将所有java文件全部重新编译一遍，而这有时候是很不必要的，因为其实只要重新编译更改的文件即可，针对这一点我写了一个根据文件更改时间选择编译的插件，这个放到之后的play应用中再谈。</li></ol><p>下面就是java预编译的主要代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//判断是否有插件会进行编译</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>Play.<span style=color:#a6e22e>pluginCollection</span>.<span style=color:#a6e22e>compileSources</span>()) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>ApplicationClass<span style=color:#f92672>&gt;</span> all <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>ApplicationClass<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在javaPath中找所有类</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (VirtualFile virtualFile : Play.<span style=color:#a6e22e>javaPath</span>) {
</span></span><span style=display:flex><span>        all.<span style=color:#a6e22e>addAll</span>(getAllClasses(virtualFile));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> classNames <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//将所有类名组成list</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> all.<span style=color:#a6e22e>size</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            ApplicationClass applicationClass <span style=color:#f92672>=</span> all.<span style=color:#a6e22e>get</span>(i);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (applicationClass <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>applicationClass.<span style=color:#a6e22e>compiled</span> <span style=color:#f92672>&amp;&amp;</span> applicationClass.<span style=color:#a6e22e>isClass</span>()) {
</span></span><span style=display:flex><span>            classNames.<span style=color:#a6e22e>add</span>(all.<span style=color:#a6e22e>get</span>(i).<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//调用编译器编译</span>
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>classes</span>.<span style=color:#a6e22e>compiler</span>.<span style=color:#a6e22e>compile</span>(classNames.<span style=color:#a6e22e>toArray</span>(<span style=color:#66d9ef>new</span> String<span style=color:#f92672>[</span>classNames.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>]</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//遍历所有类，添加至allClasses，即ApplicationClasses容器中</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (ApplicationClass applicationClass : Play.<span style=color:#a6e22e>classes</span>.<span style=color:#a6e22e>all</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//loadApplicationClass方法关键代码如下</span>
</span></span><span style=display:flex><span>    Class clazz <span style=color:#f92672>=</span> loadApplicationClass(applicationClass.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (clazz <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        allClasses.<span style=color:#a6e22e>add</span>(clazz);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>//从ApplicationClasses容器中找对应的ApplicationClass</span>
</span></span><span style=display:flex><span>ApplicationClass applicationClass <span style=color:#f92672>=</span> Play.<span style=color:#a6e22e>classes</span>.<span style=color:#a6e22e>getApplicationClass</span>(name);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (applicationClass <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//isDefinable方法就是判断applicationClass是否已经编译且存在对应的javaClass</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (applicationClass.<span style=color:#a6e22e>isDefinable</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> applicationClass.<span style=color:#a6e22e>javaClass</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//查找之前是否存在编译结果</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bc <span style=color:#f92672>=</span> BytecodeCache.<span style=color:#a6e22e>getBytecode</span>(name, applicationClass.<span style=color:#a6e22e>javaSource</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;Compiling code for %s&#34;</span>, name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//判断applicationClass是一个类还是package-info</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>applicationClass.<span style=color:#a6e22e>isClass</span>()) {
</span></span><span style=display:flex><span>        definePackage(applicationClass.<span style=color:#a6e22e>getPackage</span>(), <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        loadPackage(name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//如果之前的编译结果存在，就用之前的</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (bc <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        applicationClass.<span style=color:#a6e22e>enhancedByteCode</span> <span style=color:#f92672>=</span> bc;
</span></span><span style=display:flex><span>        applicationClass.<span style=color:#a6e22e>javaClass</span> <span style=color:#f92672>=</span> defineClass(applicationClass.<span style=color:#a6e22e>name</span>, applicationClass.<span style=color:#a6e22e>enhancedByteCode</span>, 0, applicationClass.<span style=color:#a6e22e>enhancedByteCode</span>.<span style=color:#a6e22e>length</span>, protectionDomain);
</span></span><span style=display:flex><span>        resolveClass(applicationClass.<span style=color:#a6e22e>javaClass</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>applicationClass.<span style=color:#a6e22e>isClass</span>()) {
</span></span><span style=display:flex><span>            applicationClass.<span style=color:#a6e22e>javaPackage</span> <span style=color:#f92672>=</span> applicationClass.<span style=color:#a6e22e>javaClass</span>.<span style=color:#a6e22e>getPackage</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;%sms to load class %s from cache&#34;</span>, System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start, name);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> applicationClass.<span style=color:#a6e22e>javaClass</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//如果applicationClass编译过了或者编译后有字节码，进行字节码增强</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (applicationClass.<span style=color:#a6e22e>javaByteCode</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> applicationClass.<span style=color:#a6e22e>compile</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//进行字节码增强</span>
</span></span><span style=display:flex><span>        applicationClass.<span style=color:#a6e22e>enhance</span>();
</span></span><span style=display:flex><span>        applicationClass.<span style=color:#a6e22e>javaClass</span> <span style=color:#f92672>=</span> defineClass(applicationClass.<span style=color:#a6e22e>name</span>, applicationClass.<span style=color:#a6e22e>enhancedByteCode</span>, 0, applicationClass.<span style=color:#a6e22e>enhancedByteCode</span>.<span style=color:#a6e22e>length</span>, protectionDomain);
</span></span><span style=display:flex><span>        BytecodeCache.<span style=color:#a6e22e>cacheBytecode</span>(applicationClass.<span style=color:#a6e22e>enhancedByteCode</span>, name, applicationClass.<span style=color:#a6e22e>javaSource</span>);
</span></span><span style=display:flex><span>        resolveClass(applicationClass.<span style=color:#a6e22e>javaClass</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>applicationClass.<span style=color:#a6e22e>isClass</span>()) {
</span></span><span style=display:flex><span>            applicationClass.<span style=color:#a6e22e>javaPackage</span> <span style=color:#f92672>=</span> applicationClass.<span style=color:#a6e22e>javaClass</span>.<span style=color:#a6e22e>getPackage</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Logger.<span style=color:#a6e22e>isTraceEnabled</span>()) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;%sms to load class %s&#34;</span>, System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start, name);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> applicationClass.<span style=color:#a6e22e>javaClass</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Play.<span style=color:#a6e22e>classes</span>.<span style=color:#a6e22e>classes</span>.<span style=color:#a6e22e>remove</span>(name);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=模板预编译>模板预编译<a hidden class=anchor aria-hidden=true href=#模板预编译>#</a></h3><p>不同于java的预编译，模板的预编译结果虽然也会存放在precompile文件夹，但是在运行过程中模板并不是一次性全部加载的，模板的加载主要通过play.templates.TemplateLoader来进行，TemplateLoader中存放了使用过的模板信息。
在模板预编译过程中，主要是步骤如下：</p><ol><li>扫描Play.templatesPath目录下所有模板文件</li><li>遍历文件，用TemplateLoader.load来加载源文件，并进行模板编译，产生Groovy源码</li><li>对编译后的Groovy源码进行编译，并用base64加密写入文件</li></ol><p>这里只对模板预编译流程做一个梳理，至于编译的过程放在之后的模板篇再说</p><h1 id=play-framework的启动>play framework的启动<a hidden class=anchor aria-hidden=true href=#play-framework的启动>#</a></h1><p>从上一篇server与servletWrapper中我们可以发现，play framework并不是一定在脚本启动之后便启动服务器，在我们使用dev模式进行开发时也会发现，play总是需要接受到一个请求后才会有真正的启动流程。我们这一节就来看看play的启动过程是怎么样的，这个启动与server或servletWrapper的启动的区别在于，play启动后便真正开始业务处理，而server与servletWrapper的启动仅仅是启动了监听端口，当然要清楚的是servletWrapper启动时也会自动启动play</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//如果已经启动了，先停止，这里是为了dev模式的热更新</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (started) {
</span></span><span style=display:flex><span>            stop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//如果不是独立的server，即如果不是放在servlet容器中运行，注册关闭事件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( standalonePlayServer) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Can only register shutdown-hook if running as standalone server</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>shutdownHookEnabled) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>//registers shutdown hook - Now there&#39;s a good chance that we can notify</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//our plugins that we&#39;re going down when some calls ctrl+c or just kills our process..</span>
</span></span><span style=display:flex><span>                shutdownHookEnabled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>addShutdownHook</span>(<span style=color:#66d9ef>new</span> Thread() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                        Play.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//如果是dev模式启动，重新加载所有class和插件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (mode <span style=color:#f92672>==</span> Mode.<span style=color:#a6e22e>DEV</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Need a new classloader</span>
</span></span><span style=display:flex><span>            classloader <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ApplicationClassloader();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Put it in the current context for any code that relies on having it there</span>
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>setContextClassLoader</span>(classloader);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Reload plugins</span>
</span></span><span style=display:flex><span>            pluginCollection.<span style=color:#a6e22e>reloadApplicationPlugins</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 读取配置文件</span>
</span></span><span style=display:flex><span>        readConfiguration();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 配置日志</span>
</span></span><span style=display:flex><span>        String logLevel <span style=color:#f92672>=</span> configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.log&#34;</span>, <span style=color:#e6db74>&#34;INFO&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//only override log-level if Logger was not configured manually</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( <span style=color:#f92672>!</span>Logger.<span style=color:#a6e22e>configuredManually</span>) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>setUp</span>(logLevel);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Logger.<span style=color:#a6e22e>recordCaller</span> <span style=color:#f92672>=</span> Boolean.<span style=color:#a6e22e>parseBoolean</span>(configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.log.recordCaller&#34;</span>, <span style=color:#e6db74>&#34;false&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置语言</span>
</span></span><span style=display:flex><span>        langs <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>(Arrays.<span style=color:#a6e22e>asList</span>(configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.langs&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;,&#34;</span>)));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (langs.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>==</span> 1 <span style=color:#f92672>&amp;&amp;</span> langs.<span style=color:#a6e22e>get</span>(0).<span style=color:#a6e22e>trim</span>().<span style=color:#a6e22e>length</span>() <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>            langs <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>(16);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 重新加载模板</span>
</span></span><span style=display:flex><span>        TemplateLoader.<span style=color:#a6e22e>cleanCompiledCache</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置secretKey</span>
</span></span><span style=display:flex><span>        secretKey <span style=color:#f92672>=</span> configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.secret&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>trim</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (secretKey.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;No secret key defined. Sessions will not be encrypted&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置默认web encoding</span>
</span></span><span style=display:flex><span>        String _defaultWebEncoding <span style=color:#f92672>=</span> configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.web_encoding&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( _defaultWebEncoding <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> ) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Using custom default web encoding: &#34;</span> <span style=color:#f92672>+</span> _defaultWebEncoding);
</span></span><span style=display:flex><span>            defaultWebEncoding <span style=color:#f92672>=</span> _defaultWebEncoding;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Must update current response also, since the request/response triggering</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// this configuration-loading in dev-mode have already been</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// set up with the previous encoding</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>( Http.<span style=color:#a6e22e>Response</span>.<span style=color:#a6e22e>current</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> ) {
</span></span><span style=display:flex><span>                Http.<span style=color:#a6e22e>Response</span>.<span style=color:#a6e22e>current</span>().<span style=color:#a6e22e>encoding</span> <span style=color:#f92672>=</span> _defaultWebEncoding;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 加载所有class</span>
</span></span><span style=display:flex><span>        Play.<span style=color:#a6e22e>classloader</span>.<span style=color:#a6e22e>getAllClasses</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 加载路由</span>
</span></span><span style=display:flex><span>        Router.<span style=color:#a6e22e>detectChanges</span>(ctxPath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 初始化缓存</span>
</span></span><span style=display:flex><span>        Cache.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 运行插件onApplicationStart方法</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            pluginCollection.<span style=color:#a6e22e>onApplicationStart</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (Play.<span style=color:#a6e22e>mode</span>.<span style=color:#a6e22e>isProd</span>()) {
</span></span><span style=display:flex><span>                Logger.<span style=color:#a6e22e>error</span>(e, <span style=color:#e6db74>&#34;Can&#39;t start in PROD mode with errors&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (e <span style=color:#66d9ef>instanceof</span> RuntimeException) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> (RuntimeException) e;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (firstStart) {
</span></span><span style=display:flex><span>            Logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Application &#39;%s&#39; is now started !&#34;</span>, configuration.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;application.name&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>));
</span></span><span style=display:flex><span>            firstStart <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We made it</span>
</span></span><span style=display:flex><span>        started <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        startedAt <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 运行插件afterApplicationStart方法</span>
</span></span><span style=display:flex><span>        pluginCollection.<span style=color:#a6e22e>afterApplicationStart</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (PlayException e) {
</span></span><span style=display:flex><span>        started <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> { Cache.<span style=color:#a6e22e>stop</span>(); } <span style=color:#66d9ef>catch</span> (Exception ignored) {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        started <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> { Cache.<span style=color:#a6e22e>stop</span>(); } <span style=color:#66d9ef>catch</span> (Exception ignored) {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnexpectedException(e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看出play的启动和play的初始化有很多相同的地方，包括加载配置，加载日志等，启动过程有很多有意思的地方</p><ol><li>play的启动不会重置模块列表，也就是说如果在dev模式下对配置文件进行修改增加了模块必须要重启服务器，热更新是无效的。</li><li>在play的初始化过程中，如果是使用容器打开服务器时就会加载预编译文件，这时候已经读取一遍预编译源码了，所有在启动过程中的getAllClasses就不会再去查找了</li><li>插件的onApplicationStart方法一般就是执行些插件初始化的工作，所以遇到错误就会中断启动过程，而afterApplicationStart是在启动完成后在运行的，很有意思的是，用@OnApplicationStart标识的job类是在afterApplicationStart阶段运行的，而不是onApplicationStart阶段。<del>那为什么要叫这个名字</del></li></ol><p>可以看出路由的解析是在play的启动过程中进行的，具体过程就是读取路径下的路由文件，然后路由的具体解析过程放在模板篇一起讲吧</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>Play类的初始化与启动已经说的差不多了，下一篇我们来看下ActionInvoker与mvc</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://example.org/tags/program/>Program</a></li><li><a href=https://example.org/tags/backend/>Backend</a></li></ul><nav class=paginav><a class=prev href=https://example.org/posts/home/%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E6%94%B9%E9%80%A0%E7%9B%AE%E5%BD%95/><span class=title>« Prev</span><br><span>家庭网络改造2024整理目录</span>
</a><a class=next href=https://example.org/posts/play-framework/part2server%E4%B8%8Eservletwrapper/><span class=title>Next »</span><br><span>Play framework源码解析 Part2:Server与ServletWrapper</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Play framework源码解析 Part3:Play的初始化与启动 on x" href="https://x.com/intent/tweet/?text=Play%20framework%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%20Part3%3aPlay%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e5%90%af%e5%8a%a8&amp;url=https%3a%2f%2fexample.org%2fposts%2fplay-framework%2fpart3play%25E7%259A%2584%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%25E4%25B8%258E%25E5%2590%25AF%25E5%258A%25A8%2f&amp;hashtags=program%2cbackend"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Play framework源码解析 Part3:Play的初始化与启动 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fexample.org%2fposts%2fplay-framework%2fpart3play%25E7%259A%2584%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%25E4%25B8%258E%25E5%2590%25AF%25E5%258A%25A8%2f&amp;title=Play%20framework%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%20Part3%3aPlay%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e5%90%af%e5%8a%a8&amp;summary=Play%20framework%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%20Part3%3aPlay%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e5%90%af%e5%8a%a8&amp;source=https%3a%2f%2fexample.org%2fposts%2fplay-framework%2fpart3play%25E7%259A%2584%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%25E4%25B8%258E%25E5%2590%25AF%25E5%258A%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Play framework源码解析 Part3:Play的初始化与启动 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fexample.org%2fposts%2fplay-framework%2fpart3play%25E7%259A%2584%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%25E4%25B8%258E%25E5%2590%25AF%25E5%258A%25A8%2f&title=Play%20framework%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%20Part3%3aPlay%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e5%90%af%e5%8a%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Play framework源码解析 Part3:Play的初始化与启动 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fexample.org%2fposts%2fplay-framework%2fpart3play%25E7%259A%2584%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%25E4%25B8%258E%25E5%2590%25AF%25E5%258A%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Play framework源码解析 Part3:Play的初始化与启动 on whatsapp" href="https://api.whatsapp.com/send?text=Play%20framework%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%20Part3%3aPlay%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e5%90%af%e5%8a%a8%20-%20https%3a%2f%2fexample.org%2fposts%2fplay-framework%2fpart3play%25E7%259A%2584%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%25E4%25B8%258E%25E5%2590%25AF%25E5%258A%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Play framework源码解析 Part3:Play的初始化与启动 on telegram" href="https://telegram.me/share/url?text=Play%20framework%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%20Part3%3aPlay%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e5%90%af%e5%8a%a8&amp;url=https%3a%2f%2fexample.org%2fposts%2fplay-framework%2fpart3play%25E7%259A%2584%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%25E4%25B8%258E%25E5%2590%25AF%25E5%258A%25A8%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Play framework源码解析 Part3:Play的初始化与启动 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Play%20framework%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%20Part3%3aPlay%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e5%90%af%e5%8a%a8&u=https%3a%2f%2fexample.org%2fposts%2fplay-framework%2fpart3play%25E7%259A%2584%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%25E4%25B8%258E%25E5%2590%25AF%25E5%258A%25A8%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://example.org/>404 NOT FOUND</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>